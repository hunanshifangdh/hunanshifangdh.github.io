<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>blog搭建</title>
      <link href="/2025/04/30/blog%E6%90%AD%E5%BB%BA/"/>
      <url>/2025/04/30/blog%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>以下是 <strong>在 Windows 10 系统上搭建 Hexo 个人博客</strong> 的环境准备指南，按照工具分类整理了安装步骤和关键命令：</p><hr><h3 id="一、基础工具安装"><a href="#一、基础工具安装" class="headerlink" title="一、基础工具安装"></a><strong>一、基础工具安装</strong></h3><h4 id="1-Git"><a href="#1-Git" class="headerlink" title="1. Git"></a><strong>1. Git</strong></h4><ul><li><p><strong>作用</strong>：用于版本控制和与 GitHub 交互。</p></li><li><p><strong>安装步骤</strong>：</p><ol><li><p>下载 Git 安装包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://git-scm.com/download/win</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20250430103112752.png" alt="image-20250430103112752"></p></li><li><p>双击安装包，按照默认选项安装（勾选 <code>Add Git to PATH</code>）。</p></li><li><p>验证安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li><li><p>效果展示：</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20250430102852382.png" alt="image-20250430102852382"></p></li></ol></li></ul><h4 id="2-Node-js-和-npm"><a href="#2-Node-js-和-npm" class="headerlink" title="2. Node.js 和 npm"></a><strong>2. Node.js 和 npm</strong></h4><ul><li><strong>作用</strong>：Hexo 是基于 Node.js 的静态博客框架，npm 是其包管理工具。</li><li><strong>安装步骤</strong>：<ol><li>下载 LTS 版本（推荐）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://nodejs.org/zh-cn/download/</span><br></pre></td></tr></table></figure></li><li>双击安装包，选择自定义安装路径（例如 <code>D:\Program Files\nodejs</code>），并勾选添加到系统环境变量。</li><li>验证安装：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v   <span class="comment"># 查看 Node.js 版本</span></span><br><span class="line">npm -v    <span class="comment"># 查看 npm 版本</span></span><br></pre></td></tr></table></figure></li><li><strong>（可选）切换为国内镜像加速安装</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><h4 id="3-Hexo-CLI"><a href="#3-Hexo-CLI" class="headerlink" title="3. Hexo CLI"></a><strong>3. Hexo CLI</strong></h4><ul><li><strong>作用</strong>：Hexo 命令行工具，用于初始化博客项目和生成静态文件。</li><li><strong>安装步骤</strong>：<ol><li>全局安装 Hexo：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li>验证安装：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><h3 id="二、Hexo-博客初始化"><a href="#二、Hexo-博客初始化" class="headerlink" title="二、Hexo 博客初始化"></a><strong>二、Hexo 博客初始化</strong></h3><h4 id="1-创建博客目录"><a href="#1-创建博客目录" class="headerlink" title="1. 创建博客目录"></a><strong>1. 创建博客目录</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 D 盘创建 blog 文件夹（可根据需求修改路径）</span></span><br><span class="line"><span class="built_in">mkdir</span> D:\blog</span><br><span class="line"><span class="built_in">cd</span> D:\blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Hexo 博客项目</span></span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><blockquote><p>初始化时会从 GitHub 拉取 <code>hexo-starter</code> 仓库模板。</p></blockquote><h4 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2. 安装依赖"></a><strong>2. 安装依赖</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><blockquote><p>根据 <code>package.json</code> 安装项目所需依赖。</p></blockquote><h4 id="3-启动本地服务器"><a href="#3-启动本地服务器" class="headerlink" title="3. 启动本地服务器"></a><strong>3. 启动本地服务器</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><blockquote><p>默认访问地址：<code>http://localhost:4000</code></p></blockquote><h3 id="三、连接githup"><a href="#三、连接githup" class="headerlink" title="三、连接githup"></a>三、连接githup</h3><h4 id="一、生成并添加-SSH-密钥"><a href="#一、生成并添加-SSH-密钥" class="headerlink" title="一、生成并添加 SSH 密钥"></a><strong>一、生成并添加 SSH 密钥</strong></h4><h5 id="1-生成-SSH-密钥"><a href="#1-生成-SSH-密钥" class="headerlink" title="1. 生成 SSH 密钥"></a><strong>1. 生成 SSH 密钥</strong></h5><p>bash深色版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p><strong>2. 将公钥添加到 GitHub</strong></p><ol><li><p>复制公钥内容：</p><p>bash深色版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_ed25519.pub</span><br><span class="line">Windows是用记事本打开复制粘贴即可</span><br></pre></td></tr></table></figure></li><li><p>登录 GitHub → <strong>Settings</strong> → <strong>SSH and GPG keys</strong> → 点击 <strong>New SSH key</strong>：</p><ul><li>Title：自定义名称（如 <code>Windows Hexo Blog</code>）</li><li>Key：粘贴上一步复制的内容</li><li>点击 <strong>Add SSH key</strong></li></ul><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20250430105024657.png" alt="image-20250430105024657"></p></li></ol><hr><h4 id="二、配置-Hexo-使用-SSH-部署"><a href="#二、配置-Hexo-使用-SSH-部署" class="headerlink" title="二、配置 Hexo 使用 SSH 部署"></a><strong>二、配置 Hexo 使用 SSH 部署</strong></h4><h5 id="1-修改-config-yml-文件"><a href="#1-修改-config-yml-文件" class="headerlink" title="1. 修改 _config.yml 文件"></a><strong>1. 修改 <code>_config.yml</code> 文件</strong></h5><p>打开 Hexo 博客目录下的 <code>_config.yml</code> 文件（例如 <code>D:\blog\_config.yml</code>），找到 <code>deploy</code> 配置段，修改为：</p><p>yaml深色版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:&lt;你的GitHub用户名&gt;/&lt;你的GitHub用户名&gt;.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><blockquote><p>替换 <code>&lt;你的GitHub用户名&gt;</code> 为实际用户名。<br> 示例：若 GitHub 用户名为 <code>john</code>，则填写：</p><p>yaml深色版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo: git@github.com:john/john.github.io.git</span><br></pre></td></tr></table></figure></blockquote><hr><h4 id="三、验证-SSH-连接"><a href="#三、验证-SSH-连接" class="headerlink" title="三、验证 SSH 连接"></a><strong>三、验证 SSH 连接</strong></h4><p>bash深色版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><blockquote><p>成功时会显示：</p><p>深色版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi &lt;你的GitHub用户名&gt;! You&#x27;ve successfully authenticated...</span><br></pre></td></tr></table></figure></blockquote><hr><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20250430105215880.png" alt="image-20250430105215880"></p><h3 id="四、部署-Hexo-博客"><a href="#四、部署-Hexo-博客" class="headerlink" title="四、部署 Hexo 博客"></a><strong>四、部署 Hexo 博客</strong></h3><ol><li><p>执行以下命令：</p><p>bash深色版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>如果一切正常，不会提示输入用户名&#x2F;密码，直接完成部署。</p></li></ol><p>这里查看写的帮助文档<a href="https://gdhgxd.cn/2025/04/26/githubhelp/%E7%94%A8%E4%BA%8E%E9%80%9A%E8%BF%87githup%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E3%80%82">https://gdhgxd.cn/2025/04/26/githubhelp/用于通过githup部署个人博客。</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blog问题总结</title>
      <link href="/2025/04/30/blog%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2025/04/30/blog%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p># Lazyload</p><p># <a href="https://github.com/verlok/vanilla-lazyload">https://github.com/verlok/vanilla-lazyload</a></p><p>lazyload:</p><p> enable: false</p><p> # Specify the field to use lazyload (site or post)</p><p> field: site</p><p> placeholder:</p><p> blur: false</p><p>开启之后会出现图片加载不了问题。即打开enable和blue（模糊效果）会导致图片加载不了</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20250430130308266.png" alt="image-20250430130308266"></p><p>这里我需要说明一下，我不知道是什么情况，现在又好了，难道是网络问题？难受</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo第一篇文章</title>
      <link href="/2025/04/28/2025-4-28-hexo%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2025/04/28/2025-4-28-hexo%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的hexo第一篇文章"><a href="#这是我的hexo第一篇文章" class="headerlink" title="这是我的hexo第一篇文章"></a>这是我的hexo第一篇文章</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>swagger</title>
      <link href="/2025/04/28/Swagger/"/>
      <url>/2025/04/28/Swagger/</url>
      
        <content type="html"><![CDATA[<h3 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h3><p>使用Swagger你只需要按照它的规范去定义接口及接口相关的信息，就可以做到生成接口文档，以及在线接口调试页面。</p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@Api</td><td>用在类上，例如Controller，表示对类的说明</td></tr><tr><td>@ApiModel</td><td>用在类上，例如entity、DTO、VO</td></tr><tr><td>@ApiModelProperty</td><td>用在属性上，描述属性信息</td></tr><tr><td>@ApiOperation</td><td>用在方法上，例如Controller的方法，说明方法的用途、作用</td></tr></tbody></table><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP (Aspect-Oriented Programming, 面向切面编程) 是一种编程范式，用于将横切关注点（cross-cutting concerns）从业务逻辑中分离出来。横切关注点是指那些跨越多个类和模块的公共行为，例如日志记录、事务管理、权限控制等。</p><ol><li><strong>切面 (Aspect)</strong>：<ul><li>切面是横切关注点的模块化实现，它封装了影响多个类的行为。例如，日志记录切面可以用于在方法调用前后记录日志。</li></ul></li><li><strong>连接点 (Joinpoint)</strong>：<ul><li>连接点是在程序执行过程中某个特定的点，如方法调用、异常抛出等。切面会在这些连接点上被激活。</li></ul></li><li><strong>通知 (Advice)</strong>：<ul><li>通知是切面在特定连接点上采取的动作。通知可以是前置通知（Before）、后置通知（After）、环绕通知（Around）等。</li></ul></li><li><strong>切入点 (Pointcut)</strong>：<ul><li>切入点是一组连接点的集合，它定义了通知何时被触发。通常通过表达式来定义哪些连接点属于某个切入点。</li></ul></li><li><strong>目标对象 (Target Object)</strong>：<ul><li>目标对象是被一个或多个切面所通知的对象。通常是指业务逻辑类。</li></ul></li><li><strong>织入 (Weaving)</strong>：<ul><li>织入是指将切面代码插入到目标对象中，创建一个新的代理对象的过程。织入可以在编译时、加载时或运行时进行。</li></ul></li></ol><h3 id="AOP-的优点："><a href="#AOP-的优点：" class="headerlink" title="AOP 的优点："></a>AOP 的优点：</h3><ul><li><strong>解耦</strong>：AOP 允许开发者将横切关注点从业务逻辑中分离出来，提高了模块间的解耦。</li><li><strong>代码重用</strong>：横切关注点可以被封装成切面，这样就可以在多个地方重用这些切面。</li><li><strong>易于维护</strong>：修改横切关注点只需要修改相应的切面，而不需要修改业务逻辑代码。</li></ul><h3 id="实现-AOP-的工具和技术："><a href="#实现-AOP-的工具和技术：" class="headerlink" title="实现 AOP 的工具和技术："></a>实现 AOP 的工具和技术：</h3><ol><li><strong>Spring AOP</strong>：<ul><li>Spring AOP 是Spring框架的一部分，它提供了一种实现AOP的强大方法。Spring AOP使用代理机制来实现AOP，并且支持基于注解和XML配置的方式来定义切面。</li></ul></li><li><strong>AspectJ</strong>：<ul><li>AspectJ 是一个流行的AOP框架，它提供了一种更加强大的AOP实现方式。AspectJ可以在编译时或加载时织入切面，并且支持更复杂的切入点表达式。</li></ul></li></ol><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>自定义注解 (<code>@Autofill</code>) 是一种在Java中定义元数据的方式，可以用来标记类、方法或字段，并在运行时或编译时被处理。在Spring框架中，自定义注解通常用于控制某些行为，比如自动填充字段、事务管理、切面等方面。</p><h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><p>在Java中，<code>@Target</code> 是一个元注解，用于指定一个注解可以应用的目标类型。当你定义一个自定义注解时，可以使用 <code>@Target</code> 来限制这个注解的应用范围。</p><h3 id="Target-的作用："><a href="#Target-的作用：" class="headerlink" title="@Target 的作用："></a><code>@Target</code> 的作用：</h3><p><code>@Target</code> 元注解允许你指定自定义注解可以应用到Java语言中的哪些元素上，例如类、方法、字段、构造器等。这对于确保注解被正确使用非常重要。</p><h3 id="Target-的取值："><a href="#Target-的取值：" class="headerlink" title="@Target 的取值："></a><code>@Target</code> 的取值：</h3><p><code>@Target</code> 元注解的取值类型是 <code>ElementType</code> 枚举，它定义了Java语言中可以被注解的目标类型。以下是一些常见的 <code>ElementType</code> 值：</p><ol><li><strong>ElementType.TYPE</strong>：表示可以应用到类、接口或枚举的声明上。</li><li><strong>ElementType.FIELD</strong>：表示可以应用到字段或属性的声明上。</li><li><strong>ElementType.METHOD</strong>：表示可以应用到方法的声明上。</li><li><strong>ElementType.PARAMETER</strong>：表示可以应用到方法参数的声明上。</li><li><strong>ElementType.CONSTRUCTOR</strong>：表示可以应用到构造器的声明上。</li><li><strong>ElementType.LOCAL_VARIABLE</strong>：表示可以应用到局部变量的声明上。</li><li><strong>ElementType.ANNOTATION_TYPE</strong>：表示可以应用到注解类型的声明上。</li><li><strong>ElementType.PACKAGE</strong>：表示可以应用到包的声明上。</li><li><strong>ElementType.TYPE_PARAMETER</strong>：表示可以应用到类型参数的声明上。</li><li><strong>ElementType.TYPE_USE</strong>：表示可以应用到类型使用的任何地方，例如泛型类型参数、方法返回类型等。</li></ol><h3 id="与target等价的"><a href="#与target等价的" class="headerlink" title="与target等价的"></a>与target等价的</h3><p><code>@Retention(RetentionPolicy.RUNTIME)</code> 是一个元注解，用于指定一个自定义注解的保留策略。<code>@Retention</code> 元注解定义了注解在哪些阶段是可用的，而 <code>RetentionPolicy</code> 枚举则定义了注解的生命周期。</p><h3 id="Retention-元注解的作用："><a href="#Retention-元注解的作用：" class="headerlink" title="@Retention 元注解的作用："></a><code>@Retention</code> 元注解的作用：</h3><p><code>@Retention</code> 元注解用于指定自定义注解的保留策略，即注解在编译时、类文件或运行时是否仍然可用。</p><h3 id="RetentionPolicy-枚举的取值："><a href="#RetentionPolicy-枚举的取值：" class="headerlink" title="RetentionPolicy 枚举的取值："></a><code>RetentionPolicy</code> 枚举的取值：</h3><p><code>RetentionPolicy</code> 枚举有三个取值，分别定义了注解的生命周期：</p><ol><li><strong>SOURCE</strong>：注解仅存在于源代码中，编译时会被丢弃。</li><li><strong>CLASS</strong>：注解被编译到class文件中，但在运行时不可见。</li><li><strong>RUNTIME</strong>：注解被编译到class文件中，并且在运行时可见</li></ol><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>为致力于高性能的服务器程序，客服端程序，必须学会Netty</p><p>学习路程：从NIO编程开始，netty的底层是NIO编程，所以需要先熟悉NIO。</p><p>NIO：non-blocking IO 非阻塞IO</p><h4 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h4><p>Channel是数据双向通道；Buffer数据缓存区；Selector</p><p>多线程版设计：内存占用高，线程上下切换成本高，只适合连接数较少的场景。</p><p>线程池版设计：阻塞模式下，线程仅能处理一个socket，仅适合短链接场景。</p><p>selector版设计：配合一个线程管理多个channel，获取channel上发生的事件，这些channel工作在非阻塞模式下，不会让线程吊死在一个channel上，适合连接数多，但流量低的场景。</p><p>byteBuffer正确使用姿势</p><p>1.向buffer读入数据，比如调用channel.read(buffer)</p><p>2.调用flip()切换至读模式</p><p>3.从buffer读取数据，列如调用buffer。get()</p><p>4.调用clear（）或compact（）切换至写模式</p><p>5.重复1到4</p><p>compact方法，是把未读完的部分向前压缩，然后切换至写模式。</p><p>java.nio.HeapByteBuffer Java堆内存，读写效率较低，受到GC（垃圾回收）的影响</p><p>java.nio.DIrectByteBuffer 直接内存，读写效率高（少一次拷贝），不受影响，分配效率低</p><p>rewind 从头开始读；mark做一个标记，reset将position重置到mark的位置；allocate分配内存；scattering</p><p>容易出现问题：粘包，半包.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(source.get(i)==&#x27;\n&#x27;)&#123;</span><br><span class="line">int length = i+1 - source.position();</span><br><span class="line">ByteBuffer target = ByteBuffer.allocate(length);</span><br><span class="line">for(int j=0;j&lt;length;j++)&#123;</span><br><span class="line">target.put(source.get())</span><br><span class="line">&#125;</span><br><span class="line">debugAll(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里注意换行符只占一个字节</strong></p><p>tranferto：两个channel的数据传输；效率高，地层会利用零拷贝进行优化。</p><h4 id="nio阻塞模式"><a href="#nio阻塞模式" class="headerlink" title="nio阻塞模式"></a>nio阻塞模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();//建立服务器</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(16);</span><br><span class="line">ssc.bind(new InetSocketAddress(8080))//绑定监听端口</span><br><span class="line">List&lt;SocketChannel&gt; channels = new ArrayList&lt;&gt;();//连接集合</span><br><span class="line">While(true)&#123;</span><br><span class="line">//accept建立于客服端连接，Socketchannel用来与客服端之间通信</span><br><span class="line">SocketChannel sc = ssc.accept();</span><br><span class="line">channels.add(sc);</span><br><span class="line">for(SocketChannel channel : channels)&#123;</span><br><span class="line">//遍历，接收数据</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在accpet这里阻塞了。阻塞模式下，单线程不能去执行别的任务——解决方法，一个连接一个线程</p><p>非阻塞：线程还会继续运行。非阻塞太繁忙没有连接时也在工作，容易过劳死。解决方法使用selector</p><p>accept——会在有连接请求时触发，也叫处理事件（调用它时）</p><p>connect——是客户端有连接建立后触发</p><p>read——可读事件</p><p>write——可写事件</p><p>selector（多路复用）：select方法，没有事件发生，线程阻塞，有事件发生，线程恢复。</p><p>select在事件未处理时，它不会阻塞；事件发生后要么处理，要么取消，要么置之不理</p><p>selector会在事件发售加入数据，但不会删除。要自己移除key，否则下次处理就会有问题。</p><p>处理消息的边界：</p><p>一种是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费宽带</p><p>一种是按分隔符拆分，缺点是效率低</p><p>TLV格式：及Type类型，Length长度，Value数据，类型和长度已知的情况下，就可以方便获取消息的大小，分配合适的buffer，缺点是buffer需要提前分配，如果内容过多，影响server吞吐量。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git学习</title>
      <link href="/2025/04/28/git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/04/28/git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h2><p>在Windows环境中使用Git时，你可以使用命令行工具（如命令提示符或PowerShell）来进行各种Git操作。以下是一些常用的Git命令及其用途：</p><h3 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h3><ol><li><p><strong>初始化仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>初始化一个新的Git仓库。</p></li><li><p><strong>查看状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>显示工作区的状态，包括哪些文件已被修改、新增或删除。</p></li><li><p><strong>添加文件到暂存区</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure><p>将文件添加到暂存区准备提交。可以使用<code>.</code>来添加所有修改过的文件。</p></li><li><p><strong>取消暂存文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file&gt;</span><br></pre></td></tr></table></figure><p>从暂存区移除文件，但保留文件内容。</p></li><li><p><strong>提交更改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Commit message&quot;</span></span><br></pre></td></tr></table></figure><p>提交暂存区的更改到本地仓库。</p></li><li><p><strong>查看提交历史</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>显示提交历史记录。</p></li><li><p><strong>撤销最近一次提交</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure><p>撤销最近一次提交，但保留更改。</p></li><li><p><strong>分支操作</strong></p><ul><li>创建分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li>切换分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li>删除分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure></li><li>显示所有分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>合并分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>合并指定分支到当前分支。</p></li><li><p><strong>标签操作</strong></p><ul><li>创建标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tag-name&gt;</span><br></pre></td></tr></table></figure></li><li>删除标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tag-name&gt;</span><br></pre></td></tr></table></figure></li><li>查看所有标签<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>克隆仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repository-url&gt;</span><br></pre></td></tr></table></figure><p>从远程仓库克隆一个项目到本地。</p></li></ol><h3 id="Git-远程仓库操作"><a href="#Git-远程仓库操作" class="headerlink" title="Git 远程仓库操作"></a>Git 远程仓库操作</h3><ol><li><p><strong>添加远程仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;repository-url&gt;</span><br></pre></td></tr></table></figure><p>添加远程仓库（中间的url是占位符，请填写正确的url）。</p></li><li><p><strong>查看远程仓库信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>显示远程仓库的信息。</p></li><li><p><strong>推送提交到远程仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>将本地分支推送到远程仓库。</p></li><li><p><strong>拉取远程仓库的更新</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>从远程仓库拉取更新并合并到当前分支。</p></li><li><p><strong>从远程仓库获取所有分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure><p>获取远程仓库的所有分支更新，但不自动合并。</p></li><li><p><strong>列出远程分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><p>显示远程分支。</p></li><li><p><strong>删除远程分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>删除远程仓库中的分支。</p></li></ol><h3 id="Git-高级操作"><a href="#Git-高级操作" class="headerlink" title="Git 高级操作"></a>Git 高级操作</h3><ol><li><p><strong>撤销文件更改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><p>撤销工作区中的文件更改。</p></li><li><p><strong>重置文件到上次提交的状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commit-hash&gt; -- &lt;file&gt;</span><br></pre></td></tr></table></figure><p>将文件恢复到某个提交的状态。</p></li><li><p><strong>撤销提交（硬重置）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><p>重置当前分支到指定的提交，并丢弃自该提交以来的所有更改。</p></li><li><p><strong>查找丢失的提交</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>显示提交历史记录，包括丢失的提交。</p></li><li><p><strong>强制推送</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force</span><br></pre></td></tr></table></figure><p>强制推送，可能会覆盖远程仓库的历史记录。</p></li><li><p><strong>合并时出现冲突</strong></p><ul><li>查看冲突文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li>解决冲突后<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;resolved-file&gt;</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查找文件更改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;file&gt;</span><br></pre></td></tr></table></figure><p>查看文件中每一行的最后一次修改是在哪个提交中，以及修改者是谁。</p></li><li><p><strong>查看文件差异</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit-hash&gt; &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><p>显示两个提交之间的差异。</p></li></ol><h3 id="其他实用命令"><a href="#其他实用命令" class="headerlink" title="其他实用命令"></a>其他实用命令</h3><ol><li><p><strong>查看Git版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><p>显示当前Git的版本号。</p></li><li><p><strong>获取帮助</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure><p>显示某个Git命令的帮助信息。</p></li><li><p><strong>清理未跟踪文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f</span><br></pre></td></tr></table></figure><p>清除工作目录中未被Git跟踪的文件。</p></li><li><p><strong>查看配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>显示当前配置。</p></li><li><p><strong>设置用户名和邮箱</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>设置全局用户名和邮箱。</p></li></ol><p>这些是Git在Windows环境中的一些基本和常用的命令。如果你需要更详细的帮助或遇到具体问题，请随时告诉我！</p><h2 id="如果两个人对远程仓库进行推送，其中一个先推送成功了，另一个提交时提醒冲突，怎么解决"><a href="#如果两个人对远程仓库进行推送，其中一个先推送成功了，另一个提交时提醒冲突，怎么解决" class="headerlink" title="如果两个人对远程仓库进行推送，其中一个先推送成功了，另一个提交时提醒冲突，怎么解决"></a><strong>如果两个人对远程仓库进行推送，其中一个先推送成功了，另一个提交时提醒冲突，怎么解决</strong></h2><p>当两个人同时对同一个远程仓库进行推送时，如果其中一个先推送成功了，而另一个在之后尝试推送时发现有冲突，这种情况通常是因为两个提交之间存在内容上的差异。解决这类冲突的一般步骤如下：</p><h3 id="步骤-1-拉取最新的更改"><a href="#步骤-1-拉取最新的更改" class="headerlink" title="步骤 1: 拉取最新的更改"></a>步骤 1: 拉取最新的更改</h3><p>在尝试解决冲突之前，你需要确保你的本地仓库是最新的。执行以下命令来拉取远程仓库的最新更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>这会将远程仓库的最新更改合并到你的本地分支。如果远程仓库有新的提交，那么你的本地分支也会包含这些新的提交。</p><h3 id="步骤-2-解决冲突"><a href="#步骤-2-解决冲突" class="headerlink" title="步骤 2: 解决冲突"></a>步骤 2: 解决冲突</h3><p>当你尝试<code>git pull</code>时，如果存在冲突，Git会提示你，并且你的工作目录中会出现一些冲突标记的文件。这些文件中会有特殊的标记，指示冲突的位置，例如：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">// 你的本地更改</span><br><span class="line"><span class="comment">=======</span></span><br><span class="line">// 远程仓库的更改</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;remote-commit-hash&gt;</span><br></pre></td></tr></table></figure><p>你需要手动编辑这些文件来解决冲突。你可以选择保留、合并或删除这些更改中的任意部分。通常的做法是保留有用的更改，删除不必要的冲突标记。</p><h3 id="步骤-3-标记已解决的冲突"><a href="#步骤-3-标记已解决的冲突" class="headerlink" title="步骤 3: 标记已解决的冲突"></a>步骤 3: 标记已解决的冲突</h3><p>一旦你解决了所有冲突，你需要告诉Git哪些文件的冲突已经被解决。使用以下命令来添加这些文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;conflicted-file&gt;</span><br></pre></td></tr></table></figure><p>你可以使用<code>git status</code>来检查哪些文件还需要解决冲突。</p><h3 id="步骤-4-提交更改"><a href="#步骤-4-提交更改" class="headerlink" title="步骤 4: 提交更改"></a>步骤 4: 提交更改</h3><p>解决了所有冲突并添加了文件之后，你可以提交这些更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Resolve conflicts after pull&quot;</span></span><br></pre></td></tr></table></figure><h3 id="步骤-5-再次尝试推送"><a href="#步骤-5-再次尝试推送" class="headerlink" title="步骤 5: 再次尝试推送"></a>步骤 5: 再次尝试推送</h3><p>现在你可以再次尝试将你的更改推送到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li><strong>定期拉取最新更改</strong>：为了避免冲突，最好经常拉取远程仓库的最新更改，并且在提交之前检查是否有新的提交。</li><li><strong>使用<code>git stash</code></strong>：如果你正在进行开发并且不想中断当前的工作流程，你可以使用<code>git stash</code>来暂时存储你的更改，然后拉取最新的更改，解决冲突后再恢复你的更改：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull origin &lt;branch-name&gt;</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure></li><li><strong>使用<code>git rebase</code></strong>：如果你想要在本地分支上应用远程分支的所有新提交，可以使用<code>git rebase</code>代替<code>git pull</code>。这通常会产生更线性的提交历史，但需要注意的是，如果你已经将你的更改推送到共享的远程仓库，则不应使用<code>git rebase</code>，因为这可能会导致其他人难以追踪更改历史。</li></ul><p>按照这些步骤，你应该能够解决冲突并成功推送你的更改。如果你在解决冲突的过程中遇到任何问题，请随时告诉我！</p><h1 id="MySQL数据库密码修改"><a href="#MySQL数据库密码修改" class="headerlink" title="MySQL数据库密码修改"></a>MySQL数据库密码修改</h1><p>在 MySQL 8.0 及以上版本中，修改用户密码有两种主要的方法：使用 <code>ALTER USER</code> 命令和使用 <code>SET PASSWORD</code> 命令。下面是两种方法的具体步骤。</p><h3 id="方法一：使用-ALTER-USER-命令"><a href="#方法一：使用-ALTER-USER-命令" class="headerlink" title="方法一：使用 ALTER USER 命令"></a>方法一：使用 <code>ALTER USER</code> 命令</h3><ol><li><p><strong>登录 MySQL</strong>：<br>首先需要登录到 MySQL 数据库。如果您已经有足够的权限，可以使用管理员账号登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></li><li><p><strong>修改密码</strong>：<br>使用 <code>ALTER USER</code> 命令来修改用户的密码。例如，要修改用户名为 <code>myuser</code> 的密码，可以执行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;myuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这里 <code>&#39;myuser&#39;@&#39;localhost&#39;</code> 表示用户名为 <code>myuser</code> 的本地用户，<code>&#39;new_password&#39;</code> 是新密码。</p></li><li><p><strong>刷新权限</strong>：<br>修改密码后，通常还需要执行 <code>FLUSH PRIVILEGES</code> 来刷新权限缓存，以确保更改立即生效：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法二：使用-SET-PASSWORD-命令"><a href="#方法二：使用-SET-PASSWORD-命令" class="headerlink" title="方法二：使用 SET PASSWORD 命令"></a>方法二：使用 <code>SET PASSWORD</code> 命令</h3><ol><li><p><strong>登录 MySQL</strong>：<br>同样，首先需要登录到 MySQL 数据库。</p></li><li><p><strong>修改密码</strong>：<br>使用 <code>SET PASSWORD</code> 命令来修改用户的密码。例如，要修改用户名为 <code>myuser</code> 的密码，可以执行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;myuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="operator">=</span> PASSWORD(<span class="string">&#x27;new_password&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>刷新权限</strong>：<br>修改密码后，同样需要执行 <code>FLUSH PRIVILEGES</code> 来刷新权限缓存：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>密码策略</strong>：MySQL 8.0 默认启用了更严格的密码策略。如果设置的新密码不符合这些策略，可能会收到错误消息。可以通过调整 <code>validate_password_policy</code> 和 <code>validate_password_length</code> 等系统变量来放宽密码复杂度要求。</li><li><strong>安全连接</strong>：确保使用安全的方式连接到 MySQL 服务器，尤其是在远程连接的情况下，推荐使用 SSH 隧道或 SSL 加密连接。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>如果您想要修改名为 <code>myuser</code> 的用户的密码为 <code>new_password</code>，可以按照以下步骤操作：</p><ol><li><p>登录 MySQL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></li><li><p>执行 <code>ALTER USER</code> 命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;myuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>刷新权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></li></ol><p>完成这些步骤后，<code>myuser</code> 用户的密码就被修改为 <code>new_password</code> 了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springcloud学习</title>
      <link href="/2025/04/28/springclound%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/04/28/springclound%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="springclound学习"><a href="#springclound学习" class="headerlink" title="springclound学习"></a>springclound学习</h1><p>nacos</p><p>1.引入依赖</p><p>2.在resource里加入bootstrap.yml文件，这个文件是引导文件，优先级高于application.yml</p><p>将配置交给Nacas管理的步骤</p><p>1.在nacos中添加配置文件</p><p>2.在微服务中加入nacos的config依赖</p><p>3.在微服务中添加bootstrap.yml，配置nacos地址，当前环境，服务名称，文件后缀名。这些决定了程序启动时去nacos读取那个文件</p><p>配置自动更新</p><p>方式一</p><p>在@value主任的变量所在类上添加注解@RefreshScope</p><p>方式二</p><p>使用@configurationProperties注解</p><p>多环境配置共享</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sas学习</title>
      <link href="/2025/04/28/sas%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/04/28/sas%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>SAS系统学习：</p><p>&#96;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Column` 注解通常用于 ORM（对象关系映射）框架中，如 Hibernate 或 JPA（Java Persistence API），它用于指定 Java 类中的字段或属性如何映射到数据库表中的列。</span><br><span class="line"></span><br><span class="line">`@ExcelProperty` 注解通常用于 Excel 导入导出相关的框架中，它用于标记 Java 类中的字段或属性，以指定该字段或属性在 Excel 文件中的列名。</span><br></pre></td></tr></table></figure><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul><li><strong>Excel 导入导出</strong>：当你需要从 Excel 文件中读取数据或将数据写入 Excel 文件时，使用 <code>@ExcelProperty</code> 注解。</li><li><strong>数据库持久化</strong>：当你需要将 Java 对象映射到数据库表时，使用 <code>@Column</code> 注解。</li></ul><h4 id="ElementType-枚举值："><a href="#ElementType-枚举值：" class="headerlink" title="ElementType 枚举值："></a><code>ElementType</code> 枚举值：</h4><ul><li><code>METHOD</code>：表示注解可以应用于方法。</li><li><code>FIELD</code>：表示注解可以应用于字段（成员变量）。</li><li><code>TYPE</code>：表示注解可以应用于类、接口或枚举。</li><li><code>PARAMETER</code>：表示注解可以应用于方法参数。</li><li><code>CONSTRUCTOR</code>：表示注解可以应用于构造函数。</li><li><code>LOCAL_VARIABLE</code>：表示注解可以应用于局部变量。</li><li><code>ANNOTATION_TYPE</code>：表示注解可以应用于其他注解。</li><li><code>PACKAGE</code>：表示注解可以应用于包。</li></ul><p>@Target 用于指定注解可以应用于哪些程序元素。程序元素可以是类、方法、字段、构造函数等。@Target 元注解接受一个或多个 ElementType 枚举值作为参数，这些枚举值指定了注解可以应用于哪些类型的程序元素。</p><p><code>@Retention</code> 用于指定注解的生命周期。生命周期决定了注解在编译时和运行时的存在情况。<code>@Retention</code> 元注解接受一个 <code>RetentionPolicy</code> 枚举值作为参数。</p><ul><li><strong><code>@Target</code></strong>：用于指定注解可以应用于哪些类型的程序元素。</li><li><strong><code>@Retention</code></strong>：用于指定注解的生命周期，决定注解在编译时和运行时的存在情况。</li></ul><p>ORM（Object-Relational Mapping，对象关系映射）框架是一种编程技术，用于将对象模型中的对象与关系数据库中的表进行映射。ORM 框架的主要目的是简化数据库操作，使得开发者可以使用面向对象的方式来进行数据库交互，而不需要直接编写 SQL 语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import javax.persistence.*;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;users&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;username&quot;)</span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;email&quot;)</span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">    // 构造函数、getter 和 setter 省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Navicat 中，你可以通过 SQL 查询来格式化数据库表中某一列的数据。如果你想在查询结果中保留两位小数，可以使用 SQL 的 <code>FORMAT</code> 函数或者其他相关函数来实现这一点。</p><p>类似如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, FORMAT(column_name, 2) AS formatted_column</span><br><span class="line">FROM your_table;</span><br><span class="line">查看操作结果</span><br><span class="line">SELECT id, name, FORMAT(column_name, 2) AS formatted_column</span><br><span class="line">FROM your_table;</span><br><span class="line">永久格式化</span><br><span class="line">UPDATE your_table</span><br><span class="line">SET column_name = ROUND(column_name, 2);</span><br></pre></td></tr></table></figure><h3 id="BaseMapper-接口中定义的方法"><a href="#BaseMapper-接口中定义的方法" class="headerlink" title="BaseMapper&lt;T&gt; 接口中定义的方法"></a><code>BaseMapper&lt;T&gt;</code> 接口中定义的方法</h3><p><code>BaseMapper&lt;T&gt;</code> 接口中通常定义了以下方法：</p><ol><li>增<ul><li><code>int insert(T entity);</code>：插入一条记录。</li></ul></li><li>删<ul><li><code>int deleteById(ID primaryKey);</code>：根据主键删除一条记录。</li><li><code>int deleteByMap(@Param(&quot;cm&quot;) Map&lt;String, Object&gt; columnMap);</code>：根据 map 对象删除记录。</li></ul></li><li>改<ul><li><code>int updateById(T entity);</code>：根据主键更新一条记录。</li><li><code>int update(T entity, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; updateWrapper);</code>：根据 where 条件更新记录。</li></ul></li><li>查<ul><li><code>List&lt;T&gt; selectList(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);</code>：根据条件查询记录列表。</li><li><code>T selectOne(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);</code>：根据条件查询单条记录。</li><li><code>IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);</code>：根据条件分页查询记录列表。</li></ul></li></ol><p>CRUD 操作指的是数据库中常见的四种基本操作：Create（创建）、Read（读取）、Update（更新）和Delete（删除）。这些操作是任何应用程序与数据库交互的基础。</p><p>格式化方法：</p><p><code>String.format</code> 方法可以方便地格式化字符串。</p><p><code>DecimalFormat</code> 类提供了更强大的格式化数字的功能，特别是对于固定的小数点位数。</p><h1 id="MS的学习"><a href="#MS的学习" class="headerlink" title="MS的学习"></a>MS的学习</h1><p><code>append</code> 方法在 <code>StringBuffer</code> 类中用于将指定的内容追加到当前字符串的末尾。</p><p><code>trim</code> 方法是 <code>String</code> 类中的一个常用方法，用于去除字符串两端的空白字符。空白字符包括空格、制表符、换行符等。使用 <code>trim</code> 方法可以确保字符串在进行比较或拼接时不会因为两端的空白字符而产生意外的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * TODO 获取考官信息加载到前台动态数据表格中</span><br><span class="line"> * .本方法由 chenluwei 创建于 2019年11月13日上午10:27:36</span><br><span class="line"> * @param page</span><br><span class="line"> * @param limit</span><br><span class="line"> * @param basicMng</span><br><span class="line"> * @param pTitle</span><br><span class="line"> * @param job</span><br><span class="line"> * @return Map&lt;String,Object&gt;</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(&quot;getExaminerList&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Map&lt;String, Object&gt; getExaminerList(int page, int limit, String basicMng, String pTitle, String job, Integer subjectId, Integer majorId) &#123;</span><br><span class="line">Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();</span><br><span class="line">StringBuffer where = new StringBuffer();</span><br><span class="line">if (null != basicMng &amp;&amp; !&quot;&quot;.equals(basicMng)) &#123;</span><br><span class="line">where.append(&quot;( ms_examiner.`name` like &#x27;%&quot; + basicMng.trim() + &quot;%&#x27; or ms_examiner.mbPhone = &#x27;&quot; + basicMng.trim() + &quot;&#x27;) and &quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (null != pTitle &amp;&amp; !&quot;&quot;.equals(pTitle)) &#123;</span><br><span class="line">where.append(&quot; ms_examiner.pTitle = &#x27;&quot; + pTitle.trim() + &quot;&#x27; and &quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (null != job &amp;&amp; !&quot;&quot;.equals(job)) &#123;</span><br><span class="line">where.append(&quot; ms_examiner.job = &#x27;&quot; + job.trim() + &quot;&#x27; and &quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (null != subjectId) &#123;</span><br><span class="line">where.append(&quot; ms_examiner.subjectId = &#x27;&quot; + subjectId + &quot;&#x27; and &quot;);</span><br><span class="line">if (null != majorId) &#123;</span><br><span class="line">where.append(&quot; ms_examiner.majorId = &#x27;&quot; + majorId + &quot;&#x27; and &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">where.append(&quot; 1=1 &quot;);</span><br><span class="line">Page findByPage = this.examinerService.findByPageByLeftJoin(ExaminerVO.class, page, limit, where.toString(), null);</span><br><span class="line">result.put(&quot;code&quot;, 0);</span><br><span class="line">result.put(&quot;msg&quot;, &quot;&quot;);</span><br><span class="line">result.put(&quot;count&quot;, findByPage.getMaxRowCount());</span><br><span class="line">result.put(&quot;data&quot;, findByPage.getResultList());</span><br><span class="line">logOperation(&quot;加载考官数据&quot;, OperationType.AJAX_LOAD, true);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>where.append(“( ms_examiner.name like ‘%” + basicMng.trim() + “%’ or ms_examiner.mbPhone &#x3D; ‘“ + basicMng.trim() + “‘) and “);</p><p>这一行代码构建了一个SQL查询条件，具体如下：ms_examiner.namelike ‘% + basicMng.trim() + %’”：这部分表示考官的姓名中包含basicMng的值。</p><p>%是SQL中的通配符，表示任意字符序列。因此，like ‘%value%’表示字段中包含value的任何字符串。</p><p>or ms_examiner.mbPhone &#x3D; ‘ + basicMng.trim() + ‘：这部分表示考官的手机号等于basicMng的值。</p><p>( 和 )：括号用于将两个条件组合在一起，形成一个复合条件。</p><p>and：在SQL查询中，and用于连接多个条件。</p><p>where.append(“ 1&#x3D;1 “);作用是在所有条件之后追加 <code>1=1</code>。这是一个恒为真的条件，确保即使没有其他条件时，SQL 查询也不会因为 WHERE 子句为空而报错。</p><p>logOperation: 调用日志记录方法，记录当前的操作。</p><p>where.toString(): 将构建好的查询条件字符串传递给方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RegisterMapper</span><br><span class="line">public interface DeleteByPrimaryKeyMapper&lt;T&gt; &#123;</span><br><span class="line">    @DeleteProvider(</span><br><span class="line">        type = BaseDeleteProvider.class,</span><br><span class="line">        method = &quot;dynamicSQL&quot;</span><br><span class="line">    )</span><br><span class="line">    int deleteByPrimaryKey(Object var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RegisterMapper 是MyBatis的注解，用于注册映射器接口。这意味着MyBatis会自动扫描并注册带有此注解的接口，使其可以在应用程序中使用。</p><p>@DeleteProvider 是MyBatis的注解，用于指定动态SQL的提供者类和方法。</p><p>type &#x3D; BaseDeleteProvider.class指定了提供动态SQL的类是 <code>BaseDeleteProvider</code>。        method &#x3D; “dynamicSQL”指定了在 <code>BaseDeleteProvider</code> 类中生成动态SQL的方法名是 <code>dynamicSQL</code>|</p><h2 id="工具类作用"><a href="#工具类作用" class="headerlink" title="工具类作用"></a>工具类作用</h2><p><code>AssertUtil</code> 类是一个工具类，提供了多种方法来检查和比较对象的状态。这些方法在开发中非常有用，可以帮助开发者快速判断对象是否为空、集合是否为空、字符串是否为空等，以及比较两个对象的属性值是否相等。</p><p><code>Base64Util</code> 类是一个工具类，用于将图片文件转换为 Base64 编码的字符串。这个类的主要功能是读取图片文件的内容，并将其编码为 Base64 字符串。</p><p><code>BaseController</code> 类是一个工具类，主要用于在 Spring MVC 应用程序中获取 <code>HttpServletRequest</code>、<code>HttpServletResponse</code>、<code>HttpSession</code> 和 <code>ServletContext</code> 等对象</p><p><code>ClassType</code> 类是一个工具类，用于定义一些常用的 Java 类型常量。这些常量可以在其他类中引用，以便于类型检查和转换</p><p><code>Serializable</code> 接口是 Java 标准库中的一个接口，位于 <code>java.io</code> 包中。这个接口的主要目的是标记一个类的对象可以被序列化，即可以将其状态转换为字节流，以便于存储或传输。</p><h2 id="服务器网络判断"><a href="#服务器网络判断" class="headerlink" title="服务器网络判断"></a>服务器网络判断</h2><ol><li>检查是否有网络连接：首先需要确保服务器本身是否有正常的网络连接。可以通过ping命令或者使用网络监测工具来测试服务器是否可以与其他设备进行通信。</li><li>检查服务器网络配置：确认服务器的IP地址、子网掩码、网关等网络配置是否正确。可以通过查看服务器的网络设置或者执行ipconfig（Windows）或ifconfig（Linux）命令来获取相关信息。</li><li>检查服务器是否能够访问互联网：使用浏览器或者命令行工具（如curl或wget）尝试访问互联网上的一些常见网站，以确认服务器是否能够正常访问外部网络。如果无法访问，可能是防火墙或路由器设置问题。</li><li>检查本地网络设备：如果服务器连接到本地网络，需要检查与服务器相连的交换机、路由器等网络设备的状态。检查是否有物理连接问题、端口是否正常工作，以及设备的配置是否正确。</li><li>检查网络负载和带宽：如果服务器的网络访问速度较慢或者出现丢包现象，可能是网络负载过高或者带宽不足。可以通过网络监测工具或者流量分析工具来检测服务器的网络负载情况，以及网络带宽的使用情况。</li><li>检查防火墙设置：如果服务器安装了防火墙软件或配置了网络访问限制规则，可以检查防火墙的设置，确保访问规则没有阻止服务器对外部网络的访问。</li><li>联系网络服务提供商：如果以上步骤都没有找到问题，可以与服务器所在的数据中心或网络服务提供商联系，跟他们反映问题，并请他们协助解决。</li></ol><h1 id="java面试准备"><a href="#java面试准备" class="headerlink" title="java面试准备:"></a>java面试准备:</h1><h2 id="redis篇"><a href="#redis篇" class="headerlink" title="redis篇"></a>redis篇</h2><h3 id="最近的项目中那些使用了redis？"><a href="#最近的项目中那些使用了redis？" class="headerlink" title="最近的项目中那些使用了redis？"></a>最近的项目中那些使用了redis？</h3><p>结合项目，一是验证项目场景的真实性，二是做为深入发问的切入点。</p><p>缓存：缓存3兄弟（穿透，击穿，雪崩），双写一致，持久化，数据过期测试，数据淘汰策略</p><p>分布式锁：setnx,redisson</p><p>消息队列，延迟队列：何种数据类型</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>查询一个不存在的数据，MySQL查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库。数据访问过多，数据库宕机</p><h5 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h5><p>缓存空数据</p><h5 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h5><p>布隆过滤器：可以检索一个元素是否在一个集合中。</p><p>会有误判，所以需要误判率。</p><p>误判率：数组越小误判率越大，数组越大误判率越小，但内存使用</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些并发请求可能会瞬间把DB压垮</p><h5 id="解决方案一-1"><a href="#解决方案一-1" class="headerlink" title="解决方案一"></a>解决方案一</h5><p>互斥锁，强一致，性能差（业务范围与钱相关）</p><h5 id="解决方案二-1"><a href="#解决方案二-1" class="headerlink" title="解决方案二"></a>解决方案二</h5><p>逻辑过期，高可用，性能优，不能保证数据绝对一致</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>是指在同一时段大量的缓存key同时失效或者redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>给不同的key的ttl添加随机值</p><p>利用redis集群提高服务的可用性</p><p>给缓存业务添加降级限流策略</p><p>给业务添加多级缓存</p><p>穿透无中生有key，布隆过滤null隔离。</p><p>缓存击穿过期key，锁与非器解难题。</p><p>雪崩大量过期key，过期时间要随机。</p><p>面试必考3兄弟，可用限流来保底。</p><p>redis作为缓存，mysql的数据如何与redis进行同步呢？双写一致性</p><p>设置前提，业务背景。</p><h2 id="docker学习"><a href="#docker学习" class="headerlink" title="docker学习"></a>docker学习</h2><p>什么是docker，docker就是一个快速交付应用，运行应用的技术。</p><p>可以将程序及其依赖，运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统，运行时利用沙箱机制形成隔离容器，各个应用互不干扰。</p><h3 id="项目部署问题"><a href="#项目部署问题" class="headerlink" title="项目部署问题"></a>项目部署问题</h3><p>大型项目组件较多，运行环境较为复杂，部署时会碰到一些问题：</p><p>依赖关系复杂，容易产生兼容性问题</p><p>开发，测试，生产环境有差异</p><p>docker如何解决依赖的兼容问题的？</p><p>将应用的Libs（函数库），Deps（依赖），配置与应用一起打包</p><p>将每个应用放到一个隔离容器去运行，避免相互干扰</p><p>不同环境操作系统不同，docker怎么解决？</p><p>docker将用户程序与所调用的系统（比如Ubuntu）函数库一起打包</p><p>docker运行到不同操作系统时，直接基于打包的库函数，借助于操作系统的Linux内核来运行。</p><p>虚拟机是操作系统中模拟硬件设备，然后运行另一个操作系统。</p><p>docker架构</p><p>docker是一个cs架构的程序，由两部分组成：</p><p>服务端：docker守护进程，负责处理docker指令，管理镜像，容器等。</p><p>客服端：通过命令或restAPI向docker服务端发送指令。可以在本地或远程服务端发送指令。</p><h4 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h4><p>卸载旧版本docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \</span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \</span><br><span class="line">docker-selinux \</span><br><span class="line">docker-engine-selinux \</span><br><span class="line">docker-engine \</span><br><span class="line">docker-ce</span><br></pre></td></tr></table></figure><h4 id="安装yum工具："><a href="#安装yum工具：" class="headerlink" title="安装yum工具："></a>安装yum工具：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">device-mapper-persistent-data \</span><br><span class="line">lvm2 --skip-borken</span><br></pre></td></tr></table></figure><h4 id="更新镜像源："><a href="#更新镜像源：" class="headerlink" title="更新镜像源："></a>更新镜像源：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更新为阿里云镜像源</span><br></pre></td></tr></table></figure><h4 id="输入命令"><a href="#输入命令" class="headerlink" title="输入命令"></a>输入命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install y docker-ce //docker-ce为社区免费版本。</span><br></pre></td></tr></table></figure><p>启动docker需要关闭防火墙。</p><p>关闭防火墙：systemctl stop firewalld</p><p>systemctl disable firewalld</p><p>启动docker：</p><p>systemctl start docker</p><p>查看是否成功dockers -v查看版本。</p><h2 id="docker基本操作"><a href="#docker基本操作" class="headerlink" title="docker基本操作"></a>docker基本操作</h2><p>镜像相关命令</p><p>镜像名称一般分为两部分组成:[repository]:[tag]</p><p>在没有指定tag时，默认是latest，代表最新版本的镜像</p><p>docker build 构建镜像</p><p>docker imges 查看镜像</p><p>docker rmi 删除镜像</p><p>docker pull 从服务拉取镜像</p><p>docker push 推送镜像到服务</p><p>docker save 压缩</p><p>docker load 解压 </p><p>  容器相关命令</p><p>docker run 运行</p><p>docker exec 进入容器</p><p>docker logs 查看容器运行日志</p><p>docker ps 查看所有和运行的容器</p><p>docker rm 删除指定容器</p><p>docker pause暂停</p><p>docker unpause </p><p>docker start </p><p>docker stop 停止</p><h4 id="创建运行一个nginx容器"><a href="#创建运行一个nginx容器" class="headerlink" title="创建运行一个nginx容器"></a>创建运行一个nginx容器</h4><p>步骤一：取dockerhub上查看nginx的容器运行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p>docker run : 创建并运行一个容器</p><p>–name: 给容器起一个名字，比如叫做mn</p><p>-p: 将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</p><p>-d： 后台运行容器</p><p>nginx：镜像名称</p><h4 id="进入容器内部，修改HTML文件内容"><a href="#进入容器内部，修改HTML文件内容" class="headerlink" title="进入容器内部，修改HTML文件内容"></a>进入容器内部，修改HTML文件内容</h4><p>步骤一：进入容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mn bash</span><br></pre></td></tr></table></figure><p>docker exec ：进入容器内部，执行一个命令</p><p>-it： 给当前进入的容器创建一个标准输入，输出终端，允许我们与容器交互</p><p>mn：要进入的容器的名称</p><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p><h4 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h4><p>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p>容器与数据耦合的问题</p><p>不便于修改</p><p>数据不可复用</p><p>升级维护困难</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure><p>create 创建一个volume</p><p>inspect 显示一个或多个volume的信息</p><p>Ls列出所有的volume</p><p>prune 删除未使用的volume</p><p>rm 删除一个或多个指定的volume</p><h1 id="微服务学习"><a href="#微服务学习" class="headerlink" title="微服务学习"></a>微服务学习</h1><h2 id="eureka框架"><a href="#eureka框架" class="headerlink" title="eureka框架"></a>eureka框架</h2><p>微服务角色有两类：</p><h3 id="EurekaServer：服务端，注册中心"><a href="#EurekaServer：服务端，注册中心" class="headerlink" title="EurekaServer：服务端，注册中心"></a>EurekaServer：服务端，注册中心</h3><p>记录服务信息</p><p>心跳监控：发送http请求</p><h3 id="EurekaClient：客服端"><a href="#EurekaClient：客服端" class="headerlink" title="EurekaClient：客服端"></a>EurekaClient：客服端</h3><p>服务提供者：注册自己的信息到EurekaServer</p><p>每隔30秒发送心跳，即发送http请求</p><p>服务消费者：根据服务名称从EurekaServer拉取服务列表</p><p>基于服务列表做负载均衡，选中一个微服务后发起远程调用 </p><p>搭建注册中心》服务注册》服务发现</p><p>依赖注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- eureka服务端 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.18.30&lt;/version&gt; &lt;!-- 使用最新版本 --&gt;</span><br><span class="line">           &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>.yml文件修改:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 10086 # 服务端口</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eurekaserver # eureka的服务名称</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:  # eureka的地址信息</span><br><span class="line">      defaultZone: http://127.0.0.1:10086/eureka</span><br></pre></td></tr></table></figure><p>restTemplate修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;http://userservice/user/&quot; + order.getUserId();</span><br><span class="line">//这里把具体的网络端口改成userservice</span><br><span class="line">//加入注解@LoadBalanced</span><br><span class="line">@LoadBalanced</span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="调整负载均衡规则："><a href="#调整负载均衡规则：" class="headerlink" title="调整负载均衡规则："></a>调整负载均衡规则：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">Public IRule randomRule&#123;</span><br><span class="line">return new randomRule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用全局。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userservice:</span><br><span class="line">ribbon:</span><br><span class="line">NFLoadBalancerRuleClassName: com.netflix.loadbalaner.RandomRule</span><br></pre></td></tr></table></figure><p>作用服务器。局部作用</p><h2 id="springMvc"><a href="#springMvc" class="headerlink" title="springMvc"></a>springMvc</h2><p>入门案例</p><p>报错解决：</p><p>[ERROR] Failed to execute goal <em>org.apache.maven.plugins:maven-resources-plugin:3.3.0:resources</em> (default-resources) on project springmvc_01_quickstart: Execution default-resources of goal org.apache.maven.plugins:maven-resources-plugin:3.3.0:resources failed: Unable to load the mojo ‘resources’ (or one of its required components) from the plugin ‘org.apache.maven.plugins:maven-resources-plugin:3.3.0’: com.google.inject.ProvisionException: Unable to provision, see the following errors: [ERROR]</p><p>解决加入插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.3.1&lt;/version&gt; &lt;!-- 使用最新版本 --&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>springmvc主要进行处理请求的控制器类，定义处理请求的控制器方法，并配置映射路径与返回json数据。</p><p>流程：</p><p>容器初始化：</p><p>1.服务器启动，指向servletContainersInitConfig类，初始化web容器</p><p>2.指向createServletApplicationContext方法，创建了WebApplicationContext对象</p><p>3.加载SpringMvcConfig</p><p>4.执行@ComponenScan加载对应的bean</p><p>5.加载userController，每个@RequestMapping的名称对应一个具体的方法</p><p>6.执行getServletMappings方法，定义所有的请求都通过SpringMVC</p><p>单次请求过程</p><p>1.发送请求Localhost&#x2F;save</p><p>2.web容器发现所有请求都经过springMvc，将请求交给springMvc处理</p><p>3.解析请求路径&#x2F;save</p><p>4.由&#x2F;save匹配执行对应的方法save</p><p>5.执行save</p><p>6检测到有@ResponseBody直接将save方法的返回值作为响应请求体返回给请求方</p><h3 id="因为功能不同，如何避免spring错误的加载到springMvc的bean？"><a href="#因为功能不同，如何避免spring错误的加载到springMvc的bean？" class="headerlink" title="因为功能不同，如何避免spring错误的加载到springMvc的bean？"></a>因为功能不同，如何避免spring错误的加载到springMvc的bean？</h3><p>加载spring控制的bean的时候排除掉springmvc控制的bean。</p><p>方式1：spring加载的bean设定扫描范围为com.itheima.排除掉controller包内的bean。</p><p>方式2：spring扫描设为精准范围。</p><p>@ComponentScan</p><p>类型：类注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(vale = &quot;com.itheima&quot;,</span><br><span class="line">@ComponentScan.Filter(</span><br><span class="line">type = FilterType.ANNOTATION,</span><br><span class="line">classes = Controller.class))</span><br><span class="line"></span><br><span class="line">public class SpringConfig&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>excludeFilters:排除扫描路径中加载的bean，需要指定类别和具体项。</p><p>includeFilters：加载指定的bean，需要指定类别和具体项</p><h3 id="Spring-Boot-解决-Spring-与-Spring-MVC-的-Bean-扫描问题"><a href="#Spring-Boot-解决-Spring-与-Spring-MVC-的-Bean-扫描问题" class="headerlink" title="Spring Boot 解决 Spring 与 Spring MVC 的 Bean 扫描问题"></a>Spring Boot 解决 Spring 与 Spring MVC 的 Bean 扫描问题</h3><p>Spring Boot 通过自动配置机制巧妙地解决了传统 Spring 和 Spring MVC 应用中可能出现的 Bean 扫描冲突问题。以下是其解决方案的核心要点：</p><h4 id="1-自动配置与组件扫描分离"><a href="#1-自动配置与组件扫描分离" class="headerlink" title="1. 自动配置与组件扫描分离"></a>1. 自动配置与组件扫描分离</h4><p>Spring Boot 使用 <code>@SpringBootApplication</code> 注解（组合了 <code>@Configuration</code>, <code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>）来启动应用，其中：</p><ul><li><code>@ComponentScan</code> 默认扫描主类所在包及其子包</li><li><code>@EnableAutoConfiguration</code> 负责加载 Spring Boot 提供的自动配置</li></ul><h4 id="2-区分-Web-和非-Web-配置"><a href="#2-区分-Web-和非-Web-配置" class="headerlink" title="2. 区分 Web 和非 Web 配置"></a>2. 区分 Web 和非 Web 配置</h4><p>Spring Boot 自动配置会检测应用是否是 Web 应用，并相应配置：</p><ul><li>对于 Web 应用，会自动配置 <code>DispatcherServlet</code> 和相关的 MVC 组件</li><li>非 Web 应用则不会加载这些配置</li></ul><h4 id="3-内部实现机制"><a href="#3-内部实现机制" class="headerlink" title="3. 内部实现机制"></a>3. 内部实现机制</h4><p>具体来说，Spring Boot 通过以下方式解决扫描问题：</p><ol><li><p><strong>父子容器结构</strong>：传统 Spring MVC 使用父子容器，而 Spring Boot 默认使用单一容器</p><ul><li><p>子容器可以访问父容器的 Bean，但父容器不能访问子容器的 Bean</p></li><li><p>父容器：通常包含服务层、数据层等 Bean</p></li><li><p>子容器：包含控制器、视图解析器等 MVC 相关 Bean</p></li><li><p>Spring Boot 2.x 之后默认使用单一容器简化了这种结构</p></li></ul></li><li><p><strong>自动配置类条件过滤</strong>：</p><ul><li><code>WebMvcAutoConfiguration</code> 只在 Web 环境下生效</li><li>通过 <code>@ConditionalOnWebApplication</code> 等条件注解控制配置类的加载</li></ul></li><li><p><strong>组件扫描顺序控制</strong>：</p><ul><li>Spring Boot 确保核心组件先被扫描和初始化</li><li>MVC 相关组件随后加载</li></ul></li></ol><h4 id="4-自定义配置"><a href="#4-自定义配置" class="headerlink" title="4. 自定义配置"></a>4. 自定义配置</h4><p>如果需要更细粒度的控制，可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义 MVC 配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 非 Web 相关配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-避免冲突的最佳实践"><a href="#5-避免冲突的最佳实践" class="headerlink" title="5. 避免冲突的最佳实践"></a>5. 避免冲突的最佳实践</h4><ol><li>将主类放在项目根包中</li><li>避免使用 <code>@ComponentScan</code> 手动覆盖默认扫描路径</li><li>如果需要排除某些自动配置，使用 <code>@EnableAutoConfiguration(exclude = &#123;...&#125;)</code></li></ol><p>通过以上机制，Spring Boot 简化了传统 Spring MVC 中需要手动配置父子容器和重复扫描的问题，使开发者能够更专注于业务逻辑而非配置。</p><h3 id="pojo与json区别"><a href="#pojo与json区别" class="headerlink" title="pojo与json区别"></a>pojo与json区别</h3><table><thead><tr><th align="left">特性</th><th align="left">POJO</th><th align="left">JSON</th></tr></thead><tbody><tr><td align="left"><strong>可读性</strong></td><td align="left">需要熟悉 Java 语法</td><td align="left">易于人类阅读和编写</td></tr><tr><td align="left"><strong>跨平台支持</strong></td><td align="left">仅限于 Java 环境</td><td align="left">支持所有编程语言</td></tr><tr><td align="left"><strong>数据类型支持</strong></td><td align="left">支持复杂的 Java 数据类型</td><td align="left">支持基本类型和简单结构</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">在 Java 中操作高效</td><td align="left">需要解析和序列化，性能较低</td></tr><tr><td align="left"><strong>用途</strong></td><td align="left">内部数据表示</td><td align="left">数据交换和存储</td></tr></tbody></table><p>ISO 日期格式遵循 <strong>ISO 8601</strong> 标准，这是一种国际标准化的日期和时间表示方法。</p><p>Pattern 是指一种自定义的日期格式模式，通常用于编程语言或工具中，用于定义日期的显示方式。</p><p>Rest风格是一张描述访问资源的形式，使用这种风格开发叫restful</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.POST)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">特性</th><th align="left"><code>@RequestBody</code></th><th align="left"><code>@RequestParam</code></th><th align="left"><code>@PathVariable</code></th></tr></thead><tbody><tr><td align="left"><strong>数据来源</strong></td><td align="left">请求体（Request Body）</td><td align="left">URL 查询参数（Query Params）</td><td align="left">URL 路径（Path Variables）</td></tr><tr><td align="left"><strong>适用请求方法</strong></td><td align="left">POST、PUT</td><td align="left">GET</td><td align="left">GET、POST、PUT、DELETE 等</td></tr><tr><td align="left"><strong>数据类型</strong></td><td align="left">复杂对象（如 JSON）</td><td align="left">简单键值对</td><td align="left">简单值（如 ID）</td></tr><tr><td align="left"><strong>示例 URL</strong></td><td align="left">无（数据在请求体中）</td><td align="left"><code>/users?name=John&amp;age=30</code></td><td align="left"><code>/users/123</code></td></tr><tr><td align="left"><strong>示例代码</strong></td><td align="left"><code>@RequestBody User user</code></td><td align="left"><code>@RequestParam String name</code></td><td align="left"><code>@PathVariable int id</code></td></tr></tbody></table><p>拦截器（Interceptor）和过滤器（Filter）的区别与相同点的表格展示：</p><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>拦截器（Interceptor）</strong></th><th align="left"><strong>过滤器（Filter）</strong></th><th align="left"><strong>相同点</strong></th></tr></thead><tbody><tr><td align="left"><strong>作用范围</strong></td><td align="left">方法级别，通常用于AOP编程，拦截方法调用前后。</td><td align="left">请求和响应级别，作用于整个Web请求和响应的全局处理。</td><td align="left">都用于请求和响应的处理，增强应用程序功能。</td></tr><tr><td align="left"><strong>使用场景</strong></td><td align="left">Spring框架中的控制器方法拦截、RPC框架中的远程方法调用拦截。</td><td align="left">Java Web应用中的请求和响应处理（如Servlet过滤器）。</td><td align="left">都可以用于日志记录、安全控制、性能监控等。</td></tr><tr><td align="left"><strong>执行顺序</strong></td><td align="left">在Web应用中，拦截器的执行顺序在过滤器之后，因为过滤器先处理请求。</td><td align="left">在Web应用中，过滤器先于拦截器执行，因为它在请求到达Servlet之前进行处理。</td><td align="left">都遵循一定的执行顺序，且可以在请求处理链中协同工作。</td></tr><tr><td align="left"><strong>粒度</strong></td><td align="left">更细粒度，针对方法级别的拦截和控制。</td><td align="left">较粗粒度，针对整个请求和响应的全局处理。</td><td align="left">都可以对请求和响应进行干预，但粒度不同。</td></tr><tr><td align="left"><strong>实现框架</strong></td><td align="left">常见于Spring等AOP框架。</td><td align="left">常见于Java Web应用（如Servlet）。</td><td align="left">都是通过框架或容器提供的机制实现。</td></tr><tr><td align="left"><strong>典型功能</strong></td><td align="left">日志记录、权限验证、数据预处理、性能监控等。</td><td align="left">字符编码设置、响应压缩、安全控制（如身份验证）、日志记录等。</td><td align="left">功能上有重叠，例如日志记录和安全控制。</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">适用于需要对方法调用过程进行精细化控制的场景。</td><td align="left">适用于需要对整个Web请求和响应进行全局处理的场景。</td><td align="left">都用于增强应用程序的功能，但适用场景不同。</td></tr><tr><td align="left"></td><td align="left">拦截器是Spring MVC框架的一部分，专门用于在控制器（Controller）方法执行前后进行拦截和处理。它的作用主要集中在<strong>控制器层面</strong>，能够对请求的处理过程进行更细粒度的控制。</td><td align="left">过滤器是Servlet规范的一部分，作用于Spring MVC之外，主要用于对<strong>HTTP请求和响应进行全局处理</strong>。它的作用范围比拦截器更广，通常在请求进入Spring MVC框架之前就已经开始工作。</td><td align="left"></td></tr></tbody></table><h3 id="什么是代理？"><a href="#什么是代理？" class="headerlink" title="什么是代理？"></a>什么是代理？</h3><p>是一种设计模式，它允许通过一个代理对象来控制对另一个对象的访问。代理模式的核心思想是为目标对象提供一个代理，并由代理对象控制对目标对象的访问。</p><ol><li><p><strong>静态代理</strong>：</p><p>代理类和目标类实现相同的接口。</p><p>代理类在编译时就已经确定。</p></li><li><p><strong>动态代理</strong>：</p><p>代理类在运行时动态生成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">// 1. 定义接口</span><br><span class="line">interface Star &#123;</span><br><span class="line">    void sing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 创建目标类</span><br><span class="line">class BigStar implements Star &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sing() &#123;</span><br><span class="line">        System.out.println(&quot;大明星唱歌&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 创建动态代理</span><br><span class="line">class ProxyUtil &#123;</span><br><span class="line">    public static Star createProxy(Star target) &#123;</span><br><span class="line">        return (Star) Proxy.newProxyInstance(</span><br><span class="line">                ProxyUtil.class.getClassLoader(), // 类加载器</span><br><span class="line">                new Class[]&#123;Star.class&#125;, // 目标接口</span><br><span class="line">                new InvocationHandler() &#123; // 调用处理器</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        System.out.println(&quot;代理开始&quot;);</span><br><span class="line">                        Object result = method.invoke(target, args); // 调用目标方法</span><br><span class="line">                        System.out.println(&quot;代理结束&quot;);</span><br><span class="line">                        return result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试类</span><br><span class="line">public class DynamicProxyDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Star bigStar = new BigStar();</span><br><span class="line">        Star proxy = ProxyUtil.createProxy(bigStar);</span><br><span class="line">        proxy.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Proxy.newProxyInstance</code></strong>：</p><p>用于创建代理对象。</p><p>参数：</p><ol><li>类加载器（<code>ClassLoader</code>）。</li><li>目标接口数组（<code>Class&lt;?&gt;[]</code>）。</li><li>调用处理器（<code>InvocationHandler</code>）。</li></ol><p><strong><code>InvocationHandler.invoke</code></strong>：</p><p>在代理对象调用方法时执行。</p><p>参数：</p><ol><li>代理对象（<code>Object proxy</code>）。</li><li>调用的方法（<code>Method method</code>）。</li><li>方法参数（<code>Object[] args</code>）。</li></ol></li></ol><h3 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理?"></a>什么是代理?</h3><p>是 Java 提供的一种机制，允许程序在运行时动态地获取类的信息（如类名、方法、字段、构造函数等），并操作这些信息。通过反射，程序可以在运行时检查和修改对象的行为，甚至调用私有方法或访问私有字段。</p><h3 id="1-反射的核心功能"><a href="#1-反射的核心功能" class="headerlink" title="1. 反射的核心功能"></a>1. <strong>反射的核心功能</strong></h3><p>反射的主要功能包括：</p><ol><li><strong>获取类的信息</strong>：<ul><li>获取类的名称、修饰符、父类、接口、字段、方法、构造函数等。</li></ul></li><li><strong>创建对象</strong>：<ul><li>动态创建类的实例。</li></ul></li><li><strong>调用方法</strong>：<ul><li>动态调用对象的方法（包括私有方法）。</li></ul></li><li><strong>访问字段</strong>：<ul><li>动态获取或修改对象的字段值（包括私有字段）。</li></ul></li><li><strong>操作数组</strong>：<ul><li>动态创建和操作数组。</li></ul></li></ol><h3 id="2-反射的核心类"><a href="#2-反射的核心类" class="headerlink" title="2. 反射的核心类"></a>2. <strong>反射的核心类</strong></h3><p>Java 反射机制主要通过以下类和接口实现：</p><ol><li><strong><code>Class&lt;T&gt;</code></strong>：<ul><li>表示一个类或接口的类型信息。</li><li>可以通过 <code>Class.forName(&quot;类名&quot;)</code> 或 <code>对象.getClass()</code> 获取。</li></ul></li><li><strong><code>Field</code></strong>：<ul><li>表示类的字段（成员变量）。</li><li>可以通过 <code>Class.getField()</code> 或 <code>Class.getDeclaredField()</code> 获取。</li></ul></li><li><strong><code>Method</code></strong>：<ul><li>表示类的方法。</li><li>可以通过 <code>Class.getMethod()</code> 或 <code>Class.getDeclaredMethod()</code> 获取。</li></ul></li><li><strong><code>Constructor&lt;T&gt;</code></strong>：<ul><li>表示类的构造函数。</li><li>可以通过 <code>Class.getConstructor()</code> 或 <code>Class.getDeclaredConstructor()</code> 获取。</li></ul></li><li><strong><code>Modifier</code></strong>：<ul><li>提供对类、字段、方法等的修饰符（如 <code>public</code>、<code>private</code>、<code>static</code> 等）的解析。</li></ul></li></ol><h4 id="1-获取-Class-对象"><a href="#1-获取-Class-对象" class="headerlink" title="(1) 获取 Class 对象"></a>(1) <strong>获取 Class 对象</strong></h4><ul><li><p><strong><code>Class.forName(&quot;类名&quot;)</code></strong>：</p><ul><li>通过类的全限定名获取 <code>Class</code> 对象。</li></ul><p>java</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(&quot;java.util.ArrayList&quot;);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>对象.getClass()</code></strong>：</p><ul><li>通过对象获取 <code>Class</code> 对象。</li></ul><p>java</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello&quot;;</span><br><span class="line">Class&lt;?&gt; clazz = str.getClass();</span><br></pre></td></tr></table></figure></li><li><p><strong><code>类名.class</code></strong>：</p><ul><li>通过类字面量获取 <code>Class</code> 对象。</li></ul><p>java</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = String.class;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-反射的优缺点"><a href="#5-反射的优缺点" class="headerlink" title="5. 反射的优缺点"></a>5. <strong>反射的优缺点</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><strong>动态性</strong>：<ul><li>可以在运行时动态加载类、创建对象、调用方法等。</li></ul></li><li><strong>灵活性</strong>：<ul><li>可以操作私有字段和方法，突破访问限制。</li></ul></li><li><strong>通用性</strong>：<ul><li>适用于框架开发、动态代理、注解处理等场景。</li></ul></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><strong>性能开销</strong>：<ul><li>反射操作比直接调用方法或访问字段慢，因为需要额外的类型检查和动态解析。</li></ul></li><li><strong>安全性问题</strong>：<ul><li>反射可以绕过访问控制（如访问私有字段和方法），可能导致安全问题。</li></ul></li><li><strong>代码复杂性</strong>：<ul><li>反射代码通常比普通代码更复杂，可读性和维护性较差。</li></ul></li></ol><h3 id="Spring-管理与方法调用的区别"><a href="#Spring-管理与方法调用的区别" class="headerlink" title="Spring 管理与方法调用的区别"></a><strong>Spring 管理与方法调用的区别</strong></h3><table><thead><tr><th align="left">特性</th><th align="left">Spring 管理</th><th align="left">方法调用</th></tr></thead><tbody><tr><td align="left"><strong>对象创建</strong></td><td align="left">由 Spring 容器负责创建</td><td align="left">手动创建</td></tr><tr><td align="left"><strong>依赖注入</strong></td><td align="left">支持依赖注入（DI）</td><td align="left">不支持依赖注入</td></tr><tr><td align="left"><strong>生命周期管理</strong></td><td align="left">Spring 负责对象的初始化和销毁</td><td align="left">需要手动管理对象的生命周期</td></tr><tr><td align="left"><strong>配置集中化</strong></td><td align="left">通过配置文件或注解集中管理</td><td align="left">配置分散在代码中</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">适用于复杂的依赖关系和大型项目</td><td align="left">适用于简单的场景或非 Spring 项目</td></tr><tr><td align="left"><strong>代码耦合度</strong></td><td align="left">低耦合，易于维护和扩展</td><td align="left">高耦合，维护和扩展较困难</td></tr></tbody></table><h3 id="Spring-管理-DataSource-的优势"><a href="#Spring-管理-DataSource-的优势" class="headerlink" title="Spring 管理 DataSource 的优势"></a><strong>Spring 管理 <code>DataSource</code> 的优势</strong></h3><ul><li><strong>简化配置</strong>：通过配置文件或注解集中管理数据库连接信息。</li><li><strong>依赖注入</strong>：无需手动创建 <code>DataSource</code>，Spring 自动注入。</li><li><strong>连接池支持</strong>：Spring 支持多种连接池（如 HikariCP、Tomcat JDBC Pool），可以轻松切换。</li><li><strong>事务管理</strong>：Spring 提供了强大的事务管理功能，与 <code>DataSource</code> 无缝集成。</li></ul><p>表现层数据封装</p><p>前端接收数据格式-创建结果模型类，封装数据到data属性中。</p><p>前后端人员约定形式。</p><p>异常诱因：</p><p>框架内部抛出异常：使用不合规</p><p>数据层抛出的异常：外部服务器故障导致</p><p>业务层抛出的异常：业务罗欧锦书写错误导致</p><p>表现层抛出的异常：数据收集，校验等规则导致</p><p>工具类抛出的异常：因工具类书写不严谨不够健壮导致</p><p>异常处理：</p><p>所有异常放在表现层处理</p><p>以下是 <code>@RestControllerAdvice</code> 和 <code>@ExceptionHandler</code> 的对比表格：</p><table><thead><tr><th>特性</th><th><code>@RestControllerAdvice</code></th><th><code>@ExceptionHandler</code></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>定义全局异常处理类，结合 <code>@ExceptionHandler</code> 处理控制器抛出的异常。</td><td>标记处理特定异常的方法。</td></tr><tr><td><strong>使用场景</strong></td><td>用于集中管理全局异常处理逻辑，通常与 <code>@ExceptionHandler</code> 一起使用。</td><td>用于处理控制器或 <code>@RestControllerAdvice</code> 类中抛出的特定异常。</td></tr><tr><td><strong>返回值</strong></td><td>通常返回 <code>ResponseEntity</code> 或直接返回对象（自动转换为 JSON&#x2F;XML）。</td><td>通常返回 <code>ResponseEntity</code> 或直接返回对象（自动转换为 JSON&#x2F;XML）。</td></tr><tr><td><strong>作用范围</strong></td><td>默认全局生效，可通过 <code>basePackages</code> 或 <code>annotations</code> 限定范围。</td><td>仅在定义它的类中生效（控制器或 <code>@RestControllerAdvice</code> 类）。</td></tr><tr><td><strong>组合使用</strong></td><td>通常与 <code>@ExceptionHandler</code> 一起使用，提供全局异常处理能力。</td><td>通常与 <code>@RestControllerAdvice</code> 或控制器一起使用，处理特定异常。</td></tr><tr><td><strong>示例</strong></td><td><code>java @RestControllerAdvice public class GlobalExceptionHandler &#123; ... &#125; </code></td><td><code>java @ExceptionHandler(IllegalArgumentException.class) public ResponseEntity&lt;String&gt; handleException() &#123; ... &#125; </code></td></tr><tr><td><strong>灵活性</strong></td><td>更灵活，可以处理多个控制器的异常，并支持全局配置。</td><td>更具体，专注于处理特定异常。</td></tr><tr><td><strong>适用场景</strong></td><td>适用于需要统一处理多个控制器异常的复杂项目。</td><td>适用于处理特定控制器或特定异常的场景。</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>@RestControllerAdvice 更适合全局异常处理，集中管理异常逻辑。</p><p>@ExceptionHandler<code>更适合处理特定异常，通常与</code>@RestControllerAdvice&#96; 或控制器结合使用。</p><p>两者结合使用可以构建一个健壮的异常处理机制，提升代码的可维护性和可读性。</p><p>项目异常分类：</p><p>业务异常：</p><p>规范德用户行为产生的异常</p><p>不规范的用户产生的异常</p><p>解决：发送信息给用户，提醒规范操作</p><p>系统异常：</p><p>项目运行过程可预计且无法避免的异常</p><p>解决：发送信息给运维，记录日志</p><p>其他异常</p><p>编程人员未预期到的异常</p><p>解决：发送信息给编程，提醒维护，记录日志</p><h2 id="面试Star法则"><a href="#面试Star法则" class="headerlink" title="面试Star法则"></a>面试Star法则</h2><p>situation：事情是在什么情况发生；</p><p>task：你是如何明确你得任务得；</p><p>Action：争对这样得情况分析，你采用了什么行动方式</p><p>Result：结果怎么样，在这样得情况你学习到了什么</p><p>FAB法则：</p><p>feature：是什么</p><p>Advantage：比别人好在哪里</p><p>Benefit：如果雇佣你，招聘方会得到什么好处</p><p>项目经历怎么写：</p><p>1.对项目整体设计的一个感受</p><p>2.在这个项目中你负责什么，做了什么，担任什么角色</p><p>3.从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</p><p>4.在项目描述中，最好体现自己的综合素质</p><p>那些有价值的问题值得提问？</p><p>1.能不能谈谈你作为一个公司老员工对公司的感受？</p><p>2.能不能问一下，你当时因为什么原因加入这家公司，或者这家公司有那些地方吸引你？</p><p>3.我觉得我表现的不是太好，你有什么建议或者评价给我吗？</p><p>4.接下来我会有一段很长的空档期，有什么要注意或者建议学习的吗？</p><p>5这个为什么还招人</p><p>6.大概什么时候能给我回复呢？</p><h2 id="java复习"><a href="#java复习" class="headerlink" title="java复习"></a>java复习</h2><p>接口和抽象类的区别</p><p>1.接口的方法默认是public，所有方法在接口中不能实现（Java8后开始默认实现），抽象类可以有非抽象的方法</p><p>2.接口中的实例变量默认是final类型的，而抽象类则不一定</p><p>3.一个类可以实现多个接口，但最多实现一个抽象类</p><p>4.一个类实现接口的话要实现接口的所有的方法，而抽象类不一定</p><p>5.接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象，从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一个行为的规范</p><p>java集合框架</p><p>ArrayList与linkdeList异同：</p><p>1.是否保证线程安全：ArrayList与LinkedList都是不同的，也就是不保证线程安全。</p><p>2.底层数据结构：ArrayList底层使用的是Object数组；LinkedList底层使用的是双向链表数据结构。</p><p>3.插入和删除是否受元素位置的影响：ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</p><p>LinkedList采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似o(1)而数组为近似O(n);</p><p>4.是否支持快速随机访问：快速随机访问就是通过元素的序号快速获取元素对象（对应于get（int index）方法）。</p><p>5.内存空间占用：ArrayList的空间浪费主要体现在list列表的结尾会预留一定的容量空间，而LinkedList的空间浪费体现在它的每一个元素都需要消耗比ArrayList更多空间。</p><p>Vector</p><p>vector类的所有都是同步的。可以由两个线程安全地访问Vector对象，但是一个线程访问Vector地话代码要在同步上耗费大量的时间。</p><p>ArrayList不是同步的。所以不需要线程安全时考虑ArrayList。</p><p>HashMap与Hashtable的区别：</p><p>hashtable是线程安全的。里面的方法都经过synchronized修饰。</p><p>hashtable已经被淘汰了，效率低。</p><p>hashMap可以将null作为键，键只有一个，可以有多个键对应的值为null。</p><p>hashMap扩大2倍。</p><p>当链表长度超过默认长度8时，链表转换为红黑树，减少搜索时间。</p><p>hashMap与hashSet</p><p>hashSet底层是基于hashMap实现的。</p><p>collection</p><p>1.List</p><p>ArrayList</p><p>Vector</p><p>LinkedList</p><p>2.Set</p><p>HashSet</p><p>LinedHashSet</p><p>TreeSet</p><p>Map</p><p>Hashmap</p><p>LinkedHashMap</p><p>HashTable</p><p>TreeMap</p><p>Java多线程</p><p>1.synchoized关键字了解</p><p>解决的是多个线程之间访问的同步性，synchoized关键字可以保证被它修饰的方法或者代码快在任意时刻只能由一个线程执行。</p><p>2怎么使用synchronized关键字</p><p>修饰实例方法，作用于当前对象实例加锁，进入同步diamond前要获得当前对象实例的锁。</p><p>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。</p><p>synchronized与ReenTrantLock的区别</p><p>1.两者都是可重入锁</p><p>2.synchronized依赖于jvm厄尔ReenTrantLock依赖于API</p><p>3.ReenTranLock比synchronized增加了一些高级功能</p><p>如何解决多线程时变量数据不一致问题？</p><p>变量声明为volatile，这就指示jvm，这个变量是不稳定的，每次使用它都到主存中读取。作用：volatile关键字的主要作用是保证变量的可见性然后还有一个作用就是放在指令重排序。</p><p>synchronized与voliatile区别</p><p>voliatile是线程同步的轻量级实现，性能好，但是synchronized使用场景多（修饰方法以及代码块）</p><p>多线程访问volatile关键字不会发生阻塞，而synchronized可能会发送阻塞</p><p>volatile保证数据的可见性，不能保证数据的原子性。</p><p>volatile关键字主要用于解决变量在多个线程之间的可见性，而后者解决的是多个线程之间访问资源的同步性</p><p>为什么要使用线程池</p><p>线程池提供了一种现在和管理资源。每个线程池还维护一些基本统计信息。</p><p>好处：1.降低资源消耗。</p><p>2.提高响应速度</p><p>3.提高线程的可管理性。</p><p>实现Runnable和Callable接口区别：前者不会返回结果，后者会返回结果。</p><p>execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否。</p><p>submit用于执行提交需要返回值的任务。任务池返回一个future类型的对象，通过future对象可以判断任务是否执行成功。</p><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>事务：是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>银行转账，典型的事务。</p><p>默认mysql的事务自动提交，也就是说，当执行一条DML语句，mysql会立即隐式的提交事务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- 设置手动提交</span><br><span class="line">SET autocommit = 0;</span><br><span class="line"></span><br><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 执行SQL操作</span><br><span class="line">UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;</span><br><span class="line">UPDATE accounts SET balance = balance + 100 WHERE user_id = 2;</span><br><span class="line"></span><br><span class="line">-- 检查是否有错误</span><br><span class="line">-- 如果没有错误则提交</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 如果有错误则回滚</span><br><span class="line">-- ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 恢复自动提交</span><br><span class="line">SET autocommit = 1;</span><br></pre></td></tr></table></figure><p>事务的四大特性（ACID）是数据库操作的基石：</p><ol><li><strong>原子性</strong>：事务是不可分割的整体，所有操作要么全部成功，要么全部回滚，不存在中间状态。</li><li><strong>一致性</strong>：事务执行前后，数据库必须保持逻辑规则（如约束、触发器），确保数据始终有效。</li><li><strong>隔离性</strong>：并发事务相互隔离，防止脏读、幻读等问题，通过锁或MVCC机制实现。</li><li><strong>持久性</strong>：事务一旦提交，结果永久保存，即使系统故障也不丢失，依赖日志（如Redo Log）恢复。</li></ol><p>并发事务可能引发以下四类核心问题：</p><ol><li><strong>脏读</strong>（Dirty Read）<br>事务A读取了事务B<strong>未提交</strong>的修改数据，若事务B回滚，则事务A读到的是无效的”脏数据”。</li><li><strong>不可重复读</strong>（Non-repeatable Read）<br>事务A多次读取同一数据，期间事务B<strong>修改并提交</strong>了该数据，导致事务A前后读取结果不一致。</li><li><strong>幻读</strong>（Phantom Read）<br>事务A按条件查询数据，期间事务B<strong>新增或删除</strong>了符合该条件的记录，导致事务A两次查询结果集不同（如原本10条变为12条）。</li><li><strong>丢失更新</strong>（Lost Update）<br>两个事务同时读取并修改同一数据，后提交的事务会覆盖先提交的事务的修改（如并发扣款导致余额错误）。</li></ol><blockquote><p><strong>注</strong>：不可重复读针对数据值的变化，幻读针对数据行的增减。数据库通过<strong>隔离级别</strong>（如<code>READ COMMITTED</code>、<code>SERIALIZABLE</code>）控制这些问题。</p></blockquote><p>事务隔离级别分为四类，用于控制并发事务间的可见性：</p><ol><li><strong>读未提交（Read Uncommitted）</strong>：事务可读取其他事务未提交的数据，可能导致脏读、不可重复读和幻读，性能最高但安全性最差。</li><li><strong>读已提交（Read Committed）</strong>：只能读取已提交的数据，避免脏读，但可能出现不可重复读和幻读（如Oracle默认级别）。</li><li><strong>可重复读（Repeatable Read）</strong>：确保同一事务内多次读取数据结果一致，避免脏读和不可重复读，但可能发生幻读（MySQL默认级别）。</li><li><strong>串行化（Serializable）</strong>：完全隔离事务，通过强制排序避免所有并发问题，但性能最低，适用于严格要求一致性的场景。</li></ol><p>隔离级别越高，数据一致性越强，但并发性能越低，需根据业务需求权衡选择。</p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>borker</p><p>kafka服务器进程，生产者、消费者都要连接broker</p><p>一个集群由度过broker组成，功能实现Kafka集群的负载均衡，容错</p><p>producer：生产者</p><p>consumer：消费者</p><p>topic：主题，一个Kafka集群中，可以包含多个topic。一个topic可以包含多个分区</p><p>是一个逻辑结构，生产消费消息都需要指定topic</p><p>partition：Kafka集群的分布式就是由分区来实现的。一个topic中的消息可以分布在topic中的不同paritition中。</p><p>replica：副本，实现Kafka集群的容错，实现partition的容错。一个topic至少包含大于1个的副本</p><p>consumer group：消费者组，一个消费组中的消费者可以共同消费topic中的分区数据。每一个消费组都一个唯一一个的名字。配置group-id一样的消费者是属于同一个组中。</p><p>offest：偏移量。相对于消费者来说，可以通过offest来拉取数据。</p><p>消费者组</p><p>一个消费者组中可以包含多个消费者，共同来消费topic中的数据。</p><p>一个topic中如果只有一个分区，那么这个分区只能被某个组的一个消费者消费</p><p>有多少个分区，那么就可以被同一个组内的多少个消费者消费。</p><p><strong>幂等性</strong>是指对同一个操作执行一次或多次，其产生的结果是相同的。在分布式系统和API设计中，幂等性是一个非常重要的概念。</p><h3 id="Kafka-就像「快递分拣中心」"><a href="#Kafka-就像「快递分拣中心」" class="headerlink" title="Kafka 就像「快递分拣中心」"></a><strong>Kafka 就像「快递分拣中心」</strong></h3><p><strong>生活案例</strong>：<br>假设你开了一家网红奶茶店，顾客线上下单后：  </p><ul><li><strong>没有 Kafka</strong>：订单直接交给制作员，高峰期时订单堆积，店员手忙脚乱，容易漏单或出错。  </li><li><strong>使用 Kafka</strong>：订单统一送到「智能分拣中心」（Kafka），自动按顺序排队、分发到多个制作台，还能：  <ul><li><strong>抗拥堵</strong>：即使瞬间涌入1000单，系统也能平稳处理（高吞吐）。  </li><li><strong>防丢单</strong>：所有订单记录在系统，即使停电也能恢复（持久化）。  </li><li><strong>灵活扩展</strong>：新增制作台（消费者）即可提高产能（水平扩展）。</li></ul></li></ul><p><strong>好处总结</strong>：<br>✅ <strong>订单不丢失</strong>（数据可靠）<br>✅ <strong>高峰期不卡顿</strong>（高并发）<br>✅ <strong>分工更高效</strong>（解耦生产与消费）  </p><p>就像分拣中心让奶茶店忙而不乱，Kafka 让数据流<strong>井然有序</strong>。</p><h3 id="RabbitMQ-就像「餐厅服务员」"><a href="#RabbitMQ-就像「餐厅服务员」" class="headerlink" title="RabbitMQ 就像「餐厅服务员」"></a><strong>RabbitMQ 就像「餐厅服务员」</strong></h3><p><strong>生活案例</strong>：<br>假设你经营一家火锅店，顾客通过扫码点餐：  </p><ul><li><strong>没有 RabbitMQ</strong>：订单直接打印到后厨，所有菜品一起处理，导致「毛肚等10分钟，青菜却先上」的混乱情况。  </li><li><strong>使用 RabbitMQ</strong>：订单交给「智能服务员」（RabbitMQ），它会：  <ul><li><strong>按规则分发</strong>：  <ul><li>肉类订单优先给切肉间（<strong>优先级队列</strong>）  </li><li>饮料订单直达吧台（<strong>路由规则</strong>）</li></ul></li><li><strong>灵活应对需求</strong>：  <ul><li>VIP订单插队处理（<strong>消息优先级</strong>）  </li><li>某菜品缺货时，自动通知顾客（<strong>死信队列</strong>）</li></ul></li></ul></li></ul><p><strong>好处总结</strong>：<br>✅ <strong>精准投递</strong>（消息按规则路由）<br>✅ <strong>忙闲调配</strong>（消费者动态伸缩）<br>✅ <strong>异常处理</strong>（订单失败自动重试&#x2F;补偿）  </p><p>就像专业服务员让火锅店<strong>井井有条</strong>，RabbitMQ 让业务消息<strong>精准可控</strong>。  </p><hr><h3 id="对比记忆："><a href="#对比记忆：" class="headerlink" title="对比记忆："></a><strong>对比记忆</strong>：</h3><ul><li><strong>Kafka</strong>：快递分拣中心（<strong>海量订单快速流转</strong>）  </li><li><strong>RabbitMQ</strong>：餐厅服务员（<strong>精细调度每个任务</strong>）</li></ul><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>面向对象编程（OOP）的七大原则通常指的是SOLID原则加上额外的三个原则，这些原则帮助开发者创建更加健壮、可维护和灵活的软件系统。以下是这七个原则的简要介绍：</p><ol><li><p><strong>单一职责原则（Single Responsibility Principle, SRP）</strong>：</p><ul><li>一个类应该只有一个引起它变化的原因，即一个类只负责一项职责。这样可以使类更加专注于执行单一功能，从而提高内聚性。</li></ul></li><li><p><strong>开放封闭原则（Open&#x2F;Closed Principle, OCP）</strong>：</p><ul><li>软件实体（类、模块、函数等）应该是可以扩展的，但是不可修改。这意味着你可以通过添加新的代码来扩展功能，而不是改变现有的代码，有助于减少错误的风险。</li></ul></li><li><p><strong>里氏替换原则（Liskov Substitution Principle, LSP）</strong>：</p><ul><li>子类应当能够替换它们的基类而不影响程序的正确性。也就是说，使用基类的地方都可以透明地使用子类而不会出现问题。</li></ul></li><li><p><strong>接口隔离原则（Interface Segregation Principle, ISP）</strong>：</p><ul><li>不应该强迫客户端依赖于他们不使用的接口。换句话说，应将庞大的接口拆分成小而具体的接口，使得实现类只需关注自己需要的接口方法。</li></ul></li><li><p><strong>依赖倒置原则（Dependency Inversion Principle, DIP）</strong>：</p><ul><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。该原则提倡使用接口或抽象类来减少具体实现之间的耦合度。</li></ul></li><li><p><strong>迪米特法则（Law of Demeter, LoD）</strong>：</p><ul><li>也被称为最少知识原则，指一个对象应当尽可能少地了解其他对象。具体来说，对象仅与直接的朋友交流，避免内部信息暴露给不必要的对象，增强封装性并降低耦合度。</li></ul></li><li><p><strong>组合&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle, CARP）</strong>：</p><ul><li>在新对象中尽量使用已有的对象去组合，而不是通过继承来达到复用的目的。相比继承，组合提供了更大的灵活性，并且减少了由于层次结构带来的复杂性和风险。</li></ul></li></ol><h3 id="HTTP协议结构"><a href="#HTTP协议结构" class="headerlink" title="HTTP协议结构"></a>HTTP协议结构</h3><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是用于分布式、协作式和超媒体信息系统的应用层协议。它是互联网数据通信的基础，特别是在浏览器与服务器之间的交互中扮演着关键角色。HTTP协议的请求和响应消息由以下几个主要部分组成：</p><ol><li><p><strong>起始行（Start Line）</strong>：</p><ul><li><strong>请求行（Request Line）</strong>：在请求消息中，它包含了请求方法（如GET、POST）、请求的URI（统一资源标识符）以及使用的HTTP版本。</li><li><strong>状态行（Status Line）</strong>：在响应消息中，它包括了HTTP版本、状态码（表明请求的结果如何）以及状态描述。</li></ul></li><li><p><strong>头部（Headers）</strong>：</p><ul><li>包含关于请求或响应的元数据，比如内容类型、字符编码、缓存指令等。分为通用头、请求头、响应头和实体头。</li></ul></li><li><p><strong>空行（Blank Line）</strong>：</p><ul><li>用来分隔头部和接下来的消息体。</li></ul></li><li><p><strong>消息体（Body）</strong>：</p><ul><li>可选的，包含实际传输的数据，如HTML文档、图片或其他类型的文件。并非所有的HTTP请求和响应都包含消息体。</li></ul></li></ol><h3 id="23种设计模式概览"><a href="#23种设计模式概览" class="headerlink" title="23种设计模式概览"></a>23种设计模式概览</h3><h3 id="创建型模式（Creational-Patterns）"><a href="#创建型模式（Creational-Patterns）" class="headerlink" title="创建型模式（Creational Patterns）"></a>创建型模式（Creational Patterns）</h3><ol><li><strong>单例模式（Singleton）</strong>：确保一个类只有一个实例，并提供全局访问点。</li><li><strong>工厂方法（Factory Method）</strong>：定义一个用于创建对象的接口，让子类决定实例化哪一个类。</li><li><strong>抽象工厂（Abstract Factory）</strong>：提供一系列相关或依赖对象的接口，而无需指定它们具体的类。</li><li><strong>建造者模式（Builder）</strong>：将复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。</li><li><strong>原型模式（Prototype）</strong>：通过复制现有实例来创建新实例，而不是通过实例化类来创建。</li></ol><h4 id="结构型模式（Structural-Patterns）"><a href="#结构型模式（Structural-Patterns）" class="headerlink" title="结构型模式（Structural Patterns）"></a>结构型模式（Structural Patterns）</h4><ol><li><strong>适配器模式（Adapter）</strong>：允许原本由于接口不兼容而不能一起工作的类能够协同工作。</li><li><strong>桥接模式（Bridge）</strong>：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li><li><strong>组合模式（Composite）</strong>：允许你将对象组合成树形结构来表示“部分-整体”的层次结构。</li><li><strong>装饰模式（Decorator）</strong>：动态地给一个对象添加一些额外的职责。</li><li><strong>外观模式（Facade）</strong>：为复杂的子系统提供一个统一的接口，简化其使用。</li><li><strong>享元模式（Flyweight）</strong>：运用共享技术有效地支持大量细粒度的对象。</li><li><strong>代理模式（Proxy）</strong>：为其他对象提供一种代理以控制对这个对象的访问。</li></ol><h4 id="行为型模式（Behavioral-Patterns）"><a href="#行为型模式（Behavioral-Patterns）" class="headerlink" title="行为型模式（Behavioral Patterns）"></a>行为型模式（Behavioral Patterns）</h4><ol><li><strong>观察者模式（Observer）</strong>：定义一种一对多的依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</li><li><strong>策略模式（Strategy）</strong>：定义一系列算法，把它们一个个封装起来，并使它们之间可以互换使用。</li><li><strong>模板方法（Template Method）</strong>：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。</li><li><strong>解释器模式（Interpreter）</strong>：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</li><li><strong>责任链模式（Chain of Responsibility）</strong>：避免请求发送者与接收者耦合在一起，让多个对象都有机会处理请求。</li><li><strong>命令模式（Command）</strong>：将请求封装成对象，从而使你可以用不同的请求对客户进行参数化。</li><li><strong>迭代器模式（Iterator）</strong>：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。</li><li><strong>中介者模式（Mediator）</strong>：用一个中介对象来封装一系列的对象交互。</li><li><strong>备忘录模式（Memento）</strong>：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</li><li><strong>状态模式（State）</strong>：允许对象在其内部状态改变时改变它的行为。</li><li><strong>访问者模式（Visitor）</strong>：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。</li></ol><h3 id="TCP3次握手和4次挥手"><a href="#TCP3次握手和4次挥手" class="headerlink" title="TCP3次握手和4次挥手"></a>TCP3次握手和4次挥手</h3><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>三次握手的主要目的是在客户端和服务器之间建立一条可靠的双向通信通道。它确保双方都准备好进行数据传输，并且能够同步初始序列号。以下是三次握手的过程：</p><ol><li><p><strong>第一次握手</strong>：客户端发送一个SYN（同步序列编号，Synchronize Sequence Numbers）包到服务器，表示请求建立连接，同时附带客户端的初始序列号。</p></li><li><p><strong>第二次握手</strong>：服务器接收到客户端的SYN包后，需要回复一个ACK（确认字符，Acknowledgement）包作为响应，表示已经接收到客户端的请求，并且也会发送自己的SYN包给客户端，这个步骤同时包含了对客户端SYN的确认以及服务器端的SYN请求。此时，服务器进入了SYN_RECEIVED状态。</p></li><li><p><strong>第三次握手</strong>：客户端收到服务器的SYN+ACK包后，会再次发送一个ACK包给服务器以确认连接，之后双方进入ESTABLISHED状态，即连接已建立，可以开始数据传输。</p></li></ol><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p>四次挥手用于安全地关闭TCP连接，确保双方都已经完成了数据交换并且释放了资源。由于TCP连接是全双工的，意味着每个方向都需要独立关闭，因此需要四次挥手来完成这一过程：</p><ol><li><p><strong>第一次挥手</strong>：主动关闭方（通常是客户端或首先决定结束会话的一方）发送一个FIN（结束标志，Finish），表示希望断开连接。</p></li><li><p><strong>第二次挥手</strong>：被动关闭方（通常是服务器）接收到FIN后，会发送一个ACK作为响应，确认收到了对方的关闭请求。此时，主动关闭方到被动关闭方的方向上的连接被关闭，但被动关闭方到主动关闭方的方向仍可继续传输数据。</p></li><li><p><strong>第三次挥手</strong>：当被动关闭方也准备好了关闭连接时（即所有数据都已发送完毕），它会发送一个FIN给主动关闭方。</p></li><li><p><strong>第四次挥手</strong>：主动关闭方收到FIN后，会发送最后一个ACK作为响应，然后等待一段时间（通常称为TIME_WAIT状态），确保被动关闭方收到了确认信息。一旦这个时间段结束，连接才完全关闭。</p></li></ol><h3 id="从url回车到页面显示发送了什么？"><a href="#从url回车到页面显示发送了什么？" class="headerlink" title="从url回车到页面显示发送了什么？"></a>从url回车到页面显示发送了什么？</h3><p>从你在浏览器地址栏输入一个URL并按下回车键，直到页面完全显示出来，这个过程涉及多个步骤和协议。以下是详细的流程：</p><h4 id="1-DNS查询"><a href="#1-DNS查询" class="headerlink" title="1. DNS查询"></a>1. DNS查询</h4><ul><li><strong>域名解析</strong>：首先，浏览器需要将你输入的URL中的域名转换成IP地址。它会检查本地DNS缓存，如果没有找到对应的IP地址，则会向配置的DNS服务器发起查询请求。</li><li><strong>递归查询</strong>：如果本地DNS服务器没有记录，它将继续向其他DNS服务器查询，直到获得目标域名的IP地址。</li></ul><h4 id="2-建立TCP连接"><a href="#2-建立TCP连接" class="headerlink" title="2. 建立TCP连接"></a>2. 建立TCP连接</h4><ul><li><strong>三次握手</strong>：一旦获取了服务器的IP地址，浏览器会与该服务器建立TCP连接。这通过三次握手完成：<ol><li>客户端发送SYN包到服务器。</li><li>服务器回应SYN-ACK包给客户端。</li><li>客户端再发送ACK包确认连接，至此连接建立成功。</li></ol></li></ul><h4 id="3-发送HTTP-HTTPS请求"><a href="#3-发送HTTP-HTTPS请求" class="headerlink" title="3. 发送HTTP&#x2F;HTTPS请求"></a>3. 发送HTTP&#x2F;HTTPS请求</h4><ul><li><strong>HTTP请求</strong>：如果是HTTP请求，浏览器直接发送请求报文到服务器；如果是HTTPS请求，则在发送前还需要进行SSL&#x2F;TLS握手以加密通信。</li><li><strong>HTTPS握手</strong>：包括证书验证、密钥交换等步骤，确保数据传输的安全性。</li></ul><h4 id="4-接收响应"><a href="#4-接收响应" class="headerlink" title="4. 接收响应"></a>4. 接收响应</h4><ul><li><strong>服务器处理</strong>：服务器接收到请求后，根据请求的内容（如GET请求），查找相应的资源或执行相应的逻辑，并生成HTTP响应返回给客户端。</li><li><strong>状态码和消息体</strong>：响应包含状态码（如200表示成功）、响应头以及响应体（实际要展示的内容）。</li></ul><h4 id="5-渲染页面"><a href="#5-渲染页面" class="headerlink" title="5. 渲染页面"></a>5. 渲染页面</h4><ul><li><strong>HTML解析</strong>：浏览器开始解析返回的HTML文档，构建DOM树。</li><li><strong>CSS解析与渲染</strong>：同时加载外部样式表并解析CSS，构建CSSOM树，然后结合DOM树生成渲染树。</li><li><strong>JavaScript执行</strong>：遇到<code>&lt;script&gt;</code>标签时，暂停HTML解析，下载并执行脚本文件，之后继续解析剩余的HTML。</li><li><strong>布局与绘制</strong>：计算每个节点的位置大小等信息，完成布局后，将内容绘制到屏幕上。</li></ul><h4 id="6-加载附加资源"><a href="#6-加载附加资源" class="headerlink" title="6. 加载附加资源"></a>6. 加载附加资源</h4><ul><li><strong>异步加载</strong>：在整个过程中，浏览器还会异步加载图片、视频、字体等资源，并可能再次触发上述部分流程（如DNS查询、建立TCP连接等）。</li></ul><h4 id="7-结束"><a href="#7-结束" class="headerlink" title="7. 结束"></a>7. 结束</h4><ul><li>当所有资源都已加载完毕且页面完全渲染好后，用户就可以看到最终的网页了。</li></ul><p>整个过程包含了网络通信、协议处理、安全措施以及前端技术的应用等多个方面，是现代Web体验的基础。</p><h3 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h3><p>RabbitMQ在项目中主要用于实现系统间的异步通信和解耦，通过消息队列的方式让不同的服务能够独立地发送和接收消息，从而提高系统的响应速度和稳定性。它支持多种消息传递模式，如点对点和发布&#x2F;订阅，适用于处理耗时任务的异步执行、流量削峰、日志记录以及构建高可用性和可扩展性的分布式应用，确保即使在高负载情况下也能平稳运行并有效管理服务间的交互。简而言之，RabbitMQ帮助项目实现了更高效、灵活且可靠的服务间通信机制。</p><h3 id="RabbitMQ-深入讲解"><a href="#RabbitMQ-深入讲解" class="headerlink" title="RabbitMQ 深入讲解"></a>RabbitMQ 深入讲解</h3><p><strong>RabbitMQ</strong> 是一个开源的消息代理软件（消息队列），它实现了高级消息队列协议（AMQP）。RabbitMQ主要用于在分布式系统中提供可靠的消息传递服务，支持多种消息传递模式，并具有高度的可扩展性和灵活性。</p><ul><li><p><strong>核心概念</strong>：</p><ul><li><strong>生产者（Producer）</strong>：发送消息的应用程序。</li><li><strong>交换机（Exchange）</strong>：接收生产者发送的消息，并根据路由键（Routing Key）将消息转发到相应的队列。</li><li><strong>队列（Queue）</strong>：存储消息直到被消费者处理。</li><li><strong>绑定（Binding）</strong>：定义了交换机和队列之间的关系，包括路由规则。</li><li><strong>消费者（Consumer）</strong>：接收并处理队列中的消息的应用程序。</li></ul></li><li><p><strong>消息传递模式</strong>：</p><ul><li><strong>简单模式（Simple&#x2F;Around-robin Dispatching）</strong>：每个消息都被发送给下一个消费者。</li><li><strong>发布&#x2F;订阅模式（Publish&#x2F;Subscribe）</strong>：广播消息给所有消费者。</li><li><strong>路由模式（Routing）</strong>：基于路由键精确地发送消息给特定消费者。</li><li><strong>主题模式（Topics）</strong>：使用通配符路由键灵活地匹配消息到消费者。</li></ul></li><li><p><strong>特性</strong>：</p><ul><li>支持消息持久化、确认机制确保消息不丢失。</li><li>提供高可用性配置，如集群、镜像队列等。</li><li>支持多种编程语言客户端，易于集成到现有系统中。</li></ul></li></ul><h3 id="Elasticsearch-深入讲解"><a href="#Elasticsearch-深入讲解" class="headerlink" title="Elasticsearch 深入讲解"></a>Elasticsearch 深入讲解</h3><p><strong>Elasticsearch</strong> 是一个分布式的搜索和分析引擎，基于Apache Lucene构建，专为大规模数据的实时搜索和分析而设计。它非常适合全文搜索、日志分析、应用监控等多种场景。</p><ul><li><p><strong>核心概念</strong>：</p><ul><li><strong>索引（Index）</strong>：类似于传统数据库中的“数据库”，是文档的集合。</li><li><strong>类型（Type）</strong>：早期版本中类似表的概念，但在较新版本中已被弃用，推荐使用单一类型。</li><li><strong>文档（Document）</strong>：以JSON格式存储的基本信息单元，对应于传统数据库中的行。</li><li><strong>映射（Mapping）</strong>：定义文档及其字段如何被存储和索引。</li><li><strong>分片（Shards）</strong>：索引可以分成多个分片，允许水平扩展。</li><li><strong>副本（Replicas）</strong>：为了提高容错性和查询性能，每个分片可以有多个副本。</li></ul></li><li><p><strong>功能特点</strong>：</p><ul><li><strong>全文搜索</strong>：强大的倒排索引技术实现快速准确的全文检索。</li><li><strong>聚合分析</strong>：支持复杂的统计分析和数据汇总。</li><li><strong>近实时搜索</strong>：新增或修改的数据可以在秒级内被搜索到。</li><li><strong>高可用性与扩展性</strong>：通过分片和副本机制支持大规模数据集和高并发访问。</li></ul></li><li><p><strong>应用场景</strong>：</p><ul><li>日志和事件数据分析。</li><li>实时应用程序监控和报警。</li><li>构建搜索引擎前端，如网站搜索、电子商务搜索等。</li></ul></li></ul><p>总之，RabbitMQ专注于解决分布式系统中的消息传递问题，提供可靠的异步通信机制；而Elasticsearch则致力于数据的搜索和分析，尤其擅长处理非结构化数据的快速检索和复杂查询。两者在现代软件架构中扮演着不同的角色，但都能显著提升系统的功能性和效率。</p><h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><h4 id="首先表态"><a href="#首先表态" class="headerlink" title="首先表态"></a>首先表态</h4><p>如果使用合理的JVM参数配置，在大多数情况下应该是不需要进行额外的调优的。合理的初始配置通常能够满足大部分应用的需求。</p><h4 id="其次说明"><a href="#其次说明" class="headerlink" title="其次说明"></a>其次说明</h4><p>尽管如此，仍然存在少量场景需要进一步调优。我们可以对一些JVM核心指标配置监控告警，当出现波动时人为介入分析评估。这些指标包括但不限于内存使用情况、垃圾回收频率和持续时间等。</p><h4 id="实际的调优例子"><a href="#实际的调优例子" class="headerlink" title="实际的调优例子"></a>实际的调优例子</h4><p>假设有一个Web应用在高负载下响应变慢，并且频繁出现Full GC导致长时间停顿。初步分析后发现是由于老年代内存不足引起。此时可以考虑如下调整：</p><ol><li><p><strong>增加堆内存大小</strong>：</p><ul><li>将最大堆大小（<code>-Xmx</code>）和初始堆大小（<code>-Xms</code>）设置为相同的值，以避免动态扩展带来的性能损耗。例如，从2GB增加到4GB。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms4G -Xmx4G</span><br></pre></td></tr></table></figure></li><li><p><strong>调整年轻代大小</strong>：</p><ul><li>根据应用的特点调整年轻代大小（<code>-Xmn</code>）。较大的年轻代可以减少Minor GC次数但会增加每次GC的时间；较小的年轻代则相反。例如，可以尝试将年轻代设置为堆内存的三分之一。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmn1.5G</span><br></pre></td></tr></table></figure></li><li><p><strong>选择合适的垃圾收集器</strong>：</p><ul><li>切换到G1垃圾收集器（<code>-XX:+UseG1GC</code>），并根据应用需求微调G1相关的参数，例如期望的最大GC暂停时间。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC -XX:MaxGCPauseMillis=200</span><br></pre></td></tr></table></figure></li><li><p><strong>启用详细日志记录</strong>：</p><ul><li>通过设置详细的GC日志记录来帮助分析GC行为。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps</span><br></pre></td></tr></table></figure></li><li><p><strong>监控与分析</strong>：</p><ul><li>使用工具如JVisualVM或JConsole监控JVM的运行状况，包括CPU、内存使用情况、线程信息等。</li><li>设置监控告警，当出现异常波动时及时介入分析。</li></ul></li></ol><p>通过上述步骤，可以在特定场景下有效优化JVM的性能。合理配置JVM参数并结合有效的监控和分析工具，可以帮助我们更好地理解和优化应用程序的运行状态。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>力扣收获</title>
      <link href="/2025/04/28/vue/"/>
      <url>/2025/04/28/vue/</url>
      
        <content type="html"><![CDATA[<p>##内容</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">三元运算符（`l1 != null ? l1.val : 0`）相当于</span><br><span class="line">int val1;</span><br><span class="line">if (l1 != null) &#123;</span><br><span class="line">    val1 = l1.val;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    val1 = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是关于链表的详细解答，涵盖你提到的所有问题：</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><hr><h3 id="1-如何新建一个链表"><a href="#1-如何新建一个链表" class="headerlink" title="1. 如何新建一个链表"></a>1. <strong>如何新建一个链表</strong></h3><p>在 Java 中，链表是通过定义一个节点类（<code>ListNode</code>）来实现的。每个节点包含数据域和指针域。</p><h4 id="定义链表节点"><a href="#定义链表节点" class="headerlink" title="定义链表节点"></a>定义链表节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;        <span class="comment">// 数据域</span></span><br><span class="line">    ListNode next;  <span class="comment">// 指针域，指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h4><p>通过创建多个节点并链接它们来构建链表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接节点</span></span><br><span class="line">node1.next = node2;</span><br><span class="line">node2.next = node3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// node1 -&gt; node2 -&gt; node3 -&gt; null</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-使用指针指向链表头节点"><a href="#2-使用指针指向链表头节点" class="headerlink" title="2. 使用指针指向链表头节点"></a>2. <strong>使用指针指向链表头节点</strong></h3><p>在链表中，通常使用一个指针（引用）来指向链表的头节点，以便操作链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> node1;  <span class="comment">// head 指向链表的头节点</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-如何通过指针给链表数据域注入数据"><a href="#3-如何通过指针给链表数据域注入数据" class="headerlink" title="3. 如何通过指针给链表数据域注入数据"></a>3. <strong>如何通过指针给链表数据域注入数据</strong></h3><p>可以通过指针访问链表节点的数据域并修改其值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head.val = <span class="number">10</span>;  <span class="comment">// 修改头节点的值</span></span><br><span class="line">head.next.val = <span class="number">20</span>;  <span class="comment">// 修改第二个节点的值</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-如何遍历注入数据"><a href="#4-如何遍历注入数据" class="headerlink" title="4. 如何遍历注入数据"></a>4. <strong>如何遍历注入数据</strong></h3><p>遍历链表时，可以通过指针逐个访问节点并修改数据域。</p><h4 id="示例：遍历链表并修改每个节点的值"><a href="#示例：遍历链表并修改每个节点的值" class="headerlink" title="示例：遍历链表并修改每个节点的值"></a>示例：遍历链表并修改每个节点的值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;  <span class="comment">// 定义指针 current，初始指向头节点</span></span><br><span class="line"><span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">    current.val = current.val * <span class="number">2</span>;  <span class="comment">// 修改当前节点的值</span></span><br><span class="line">    current = current.next;  <span class="comment">// 移动指针到下一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-返回一个链表所有数据，怎么返回"><a href="#5-返回一个链表所有数据，怎么返回" class="headerlink" title="5. 返回一个链表所有数据，怎么返回"></a>5. <strong>返回一个链表所有数据，怎么返回</strong></h3><p>可以通过遍历链表，将每个节点的数据域存储到一个列表（如 <code>List</code>）中，然后返回该列表。</p><h4 id="示例：返回链表的所有数据"><a href="#示例：返回链表的所有数据" class="headerlink" title="示例：返回链表的所有数据"></a>示例：返回链表的所有数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getLinkedListData</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        result.add(current.val);  <span class="comment">// 将当前节点的值添加到列表</span></span><br><span class="line">        current = current.next;  <span class="comment">// 移动指针到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;  <span class="comment">// 返回链表的所有数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-Java-中链表的特点"><a href="#6-Java-中链表的特点" class="headerlink" title="6. Java 中链表的特点"></a>6. <strong>Java 中链表的特点</strong></h3><p>Java 中的链表具有以下特点：</p><h4 id="（1）动态大小"><a href="#（1）动态大小" class="headerlink" title="（1）动态大小"></a>（1）<strong>动态大小</strong></h4><ul><li>链表的大小可以动态增长或缩小，不需要预先分配固定大小的内存。</li></ul><h4 id="（2）插入和删除效率高"><a href="#（2）插入和删除效率高" class="headerlink" title="（2）插入和删除效率高"></a>（2）<strong>插入和删除效率高</strong></h4><ul><li>在链表中插入或删除节点的时间复杂度为 <strong>O(1)</strong>（如果已知插入&#x2F;删除位置）。</li><li>相比于数组，链表在中间插入或删除数据时不需要移动其他元素。</li></ul><h4 id="（3）随机访问效率低"><a href="#（3）随机访问效率低" class="headerlink" title="（3）随机访问效率低"></a>（3）<strong>随机访问效率低</strong></h4><ul><li>链表不支持随机访问，访问第 <code>n</code> 个节点需要从头节点开始遍历，时间复杂度为 <strong>O(n)</strong>。</li></ul><h4 id="（4）内存开销"><a href="#（4）内存开销" class="headerlink" title="（4）内存开销"></a>（4）<strong>内存开销</strong></h4><ul><li>每个节点除了存储数据外，还需要额外的空间存储指针（引用），因此链表的内存开销比数组大。</li></ul><h4 id="（5）实现方式"><a href="#（5）实现方式" class="headerlink" title="（5）实现方式"></a>（5）<strong>实现方式</strong></h4><ul><li>Java 提供了内置的链表实现：<code>java.util.LinkedList</code>。</li><li><code>LinkedList</code> 是一个双向链表，支持在头部和尾部高效插入和删除数据。</li></ul><h4 id="（6）适用场景"><a href="#（6）适用场景" class="headerlink" title="（6）适用场景"></a>（6）<strong>适用场景</strong></h4><ul><li>需要频繁插入和删除数据的场景。</li><li>数据量不确定或动态变化的场景。</li><li>不需要频繁随机访问数据的场景。</li></ul><hr><h3 id="完整示例代码"><a href="#完整示例代码" class="headerlink" title="完整示例代码"></a>完整示例代码</h3><p>以下是一个完整的 Java 示例，演示如何创建链表、遍历链表、修改数据并返回链表的所有数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建链表 1 -&gt; 2 -&gt; 3 -&gt; null</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表并修改数据</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            current.val = current.val * <span class="number">2</span>;  <span class="comment">// 修改每个节点的值</span></span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回链表的所有数据</span></span><br><span class="line">        List&lt;Integer&gt; result = getLinkedListData(head);</span><br><span class="line">        System.out.println(result);  <span class="comment">// 输出: [2, 4, 6]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表的所有数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">getLinkedListData</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            result.add(current.val);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>新建链表</strong>：通过定义节点类并链接节点。</li><li><strong>指针操作</strong>：使用指针（引用）指向链表头节点，并通过指针操作链表。</li><li><strong>遍历链表</strong>：通过循环逐个访问节点。</li><li><strong>返回链表数据</strong>：将链表数据存储到列表并返回。</li><li><strong>链表特点</strong>：动态大小、插入删除效率高、随机访问效率低。</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>以下是正确的 <code>for</code> 循环写法：</p><h4 id="1-完整初始化"><a href="#1-完整初始化" class="headerlink" title="1. 完整初始化"></a>1. <strong>完整初始化</strong></h4><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    // 循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-省略初始化（不推荐）"><a href="#2-省略初始化（不推荐）" class="headerlink" title="2. 省略初始化（不推荐）"></a>2. <strong>省略初始化（不推荐）</strong></h4><p>如果循环变量已经在外部定义，可以省略初始化部分，但必须保留分号：</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">for (; i &lt; nums.length; i++) &#123;</span><br><span class="line">    // 循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-省略所有部分（无限循环）"><a href="#3-省略所有部分（无限循环）" class="headerlink" title="3. 省略所有部分（无限循环）"></a>3. <strong>省略所有部分（无限循环）</strong></h4><p>如果省略所有部分，<code>for</code> 循环将变成一个无限循环：</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (;;) &#123;</span><br><span class="line">    // 无限循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-遍历数组"><a href="#4-遍历数组" class="headerlink" title="4. 遍历数组"></a>4. <strong>遍历数组</strong></h4><ul><li><p>使用 <code>for</code> 循环或 <code>for-each</code> 循环遍历数组。</p></li><li><p>示例：</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line"></span><br><span class="line">// 使用 for 循环</span><br><span class="line">for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 for-each 循环</span><br><span class="line">for (int num : nums) &#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>将两个二进制字符串相加并以二进制字符串的形式返回结果。</p><ol><li><p>从字符串的末尾（最低位）开始逐位相加。</p></li><li><p>使用一个变量 <code>carry</code> 记录进位。</p></li><li><p>将每一位的相加结果拼接到结果字符串中。</p></li><li><p>最后反转结果字符串，得到正确的顺序。</p><pre><code>    // 从末尾开始逐位相加    while (i &gt;= 0 || j &gt;= 0 || carry != 0) &#123;        int sum = carry;  // 当前位的和            // 如果 a 还有位，加上 a 的当前位        if (i &gt;= 0) &#123;            sum += a.charAt(i) - &#39;0&#39;;  // 将字符转换为数字            i--;        &#125;            // 如果 b 还有位，加上 b 的当前位        if (j &gt;= 0) &#123;            sum += b.charAt(j) - &#39;0&#39;;  // 将字符转换为数字            j--;        &#125;            // 计算当前位的结果和进位        result.append(sum % 2);  // 当前位的结果        carry = sum / 2;        // 进位值    &#125;        // 反转结果字符串    return result.reverse().toString();&#125;public static void main(String[] args) &#123;    Solution solution = new Solution();    String a = &quot;1010&quot;;    String b = &quot;1011&quot;;    System.out.println(solution.addBinary(a, b));  // 输出: &quot;10101&quot;&#125;</code></pre></li></ol><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul><li><p><strong><code>if</code> 语句</strong>：根据条件执行或不执行某段代码。</p></li><li><p><strong><code>while</code> 循环</strong>：当条件为真时，重复执行某段代码。</p></li><li><p><strong><code>for</code> 循环</strong>：根据条件重复执行某段代码，通常用于遍历或计数。</p><h4 id="（1）明确目标"><a href="#（1）明确目标" class="headerlink" title="（1）明确目标"></a>（1）<strong>明确目标</strong></h4><p>在设计条件判断之前，先明确程序的目标。</p><p>例如：</p><p>如果要遍历数组，条件判断可能是“是否到达数组末尾”。</p><p>如果要查找某个元素，条件判断可能是“当前元素是否等于目标值”。</p><h4 id="（2）确定条件表达式"><a href="#（2）确定条件表达式" class="headerlink" title="（2）确定条件表达式"></a>（2）<strong>确定条件表达式</strong></h4><p>条件表达式是一个布尔表达式，结果为 <code>true</code> 或 <code>false</code>。</p><p>常见的条件表达式包括：</p><p>比较运算：<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></p><p>逻辑运算：<code>&amp;&amp;</code>（与），<code>||</code>（或），<code>!</code>（非）</p><p>其他：<code>instanceof</code>（类型检查），<code>contains</code>（集合包含检查）</p><h4 id="（3）考虑边界条件"><a href="#（3）考虑边界条件" class="headerlink" title="（3）考虑边界条件"></a>（3）<strong>考虑边界条件</strong></h4><p>确保条件判断覆盖所有可能的边界情况。</p><p>例如：</p><p>如果遍历数组，需要考虑数组为空的情况。</p><p>如果查找元素，需要考虑元素不存在的情况。</p><h4 id="（4）优化条件判断"><a href="#（4）优化条件判断" class="headerlink" title="（4）优化条件判断"></a>（4）<strong>优化条件判断</strong></h4><p>尽量使条件判断简洁、清晰。</p><p>避免重复的条件判断。</p><p>使用适当的逻辑运算符组合条件。</p></li></ul><h3 id="全局变量与局部变量区别"><a href="#全局变量与局部变量区别" class="headerlink" title="全局变量与局部变量区别"></a>全局变量与局部变量区别</h3><table><thead><tr><th align="left">特性</th><th align="left">全局变量</th><th align="left">局部变量</th></tr></thead><tbody><tr><td align="left"><strong>作用域</strong></td><td align="left">整个类中都可以访问</td><td align="left">仅限于定义它的方法、代码块或循环内部</td></tr><tr><td align="left"><strong>生命周期</strong></td><td align="left">从对象创建到对象销毁</td><td align="left">从变量定义开始，到方法、代码块或循环结束</td></tr><tr><td align="left"><strong>默认值</strong></td><td align="left">有默认值（如 <code>int</code> 默认为 <code>0</code>）</td><td align="left">没有默认值，必须显式初始化</td></tr><tr><td align="left"><strong>访问权限</strong></td><td align="left">可以被类中的所有方法访问</td><td align="left">只能在定义它的方法、代码块或循环中访问</td></tr><tr><td align="left"><strong>内存分配</strong></td><td align="left">存储在堆内存中</td><td align="left">存储在栈内存中</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软著申请</title>
      <link href="/2025/04/28/%E8%BD%AF%E8%91%97%EF%BC%9A%E8%BD%AF%E4%BB%B6%E8%91%97%E4%BD%9C%E6%9D%83%EF%BC%8C%E5%BE%88%E6%B0%B4%EF%BC%8C%E6%9C%89%E4%B8%80%E4%B8%A4%E4%B8%AA%E5%B0%B1%E8%A1%8C%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%92%8C%E4%B8%93%E5%88%A9%E7%9B%B8%E6%AF%94/"/>
      <url>/2025/04/28/%E8%BD%AF%E8%91%97%EF%BC%9A%E8%BD%AF%E4%BB%B6%E8%91%97%E4%BD%9C%E6%9D%83%EF%BC%8C%E5%BE%88%E6%B0%B4%EF%BC%8C%E6%9C%89%E4%B8%80%E4%B8%A4%E4%B8%AA%E5%B0%B1%E8%A1%8C%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%92%8C%E4%B8%93%E5%88%A9%E7%9B%B8%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>软著：软件著作权，很水，有一两个就行，不要和专利相比</p><p>登录：身份使用个人，登录后进行实名认证</p><p>软著申请</p><p>1.原始取得方式</p><p>2.软件全场</p><p>3输入版本号</p><p>4.权力范围：全部</p><p>软件分类：应用软件，原创，单独开发（合作开发需要合作开发协议），开发日期，发表状态未发表</p><p>事业单位法人，名字写学校</p><p>软件功能与特点</p><p>硬件软件：写电脑配置</p><p>软件环境：开发软件，系统</p><p>源程序量：以3000行为分界线，以上大概，以下实际</p><p>软件技术特点：实在不行选教育软件和智慧城市软件</p><p>重新鉴别材料就是源程序代码，每页不少于50行，尽量去除注释</p><p>要设置页眉，需要软件名字</p><p>申请表：申请人签章就第一个人</p><p>设计说明书：设计思想，框架，流程图</p><p>使用手册：具体的可视化，登录界面，功能等</p><p>文档，页码要在右上角，左侧写系统名称和版本号</p><p>源代码不允许出现版权copyright,create,Author等（含相应中文），即清楚日期和版本相关注释</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>githup帮助文档</title>
      <link href="/2025/04/26/githubhelp/"/>
      <url>/2025/04/26/githubhelp/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub-Pages-快速入门"><a href="#GitHub-Pages-快速入门" class="headerlink" title="GitHub Pages 快速入门"></a>GitHub Pages 快速入门</h1><p>您可以使用 GitHub Pages 来展示一些开源项目、托管博客，甚至分享您的简历。本指南将帮助您开始创建下一个网站。</p><h2 id="谁可以使用此功能？"><a href="#谁可以使用此功能？" class="headerlink" title="谁可以使用此功能？"></a>谁可以使用此功能？</h2><p>GitHub Pages 可用于具有 GitHub Free 和适用于组织的 GitHub Free 的公共存储库，以及具有 GitHub Pro、GitHub Team、GitHub Enterprise Cloud 和 GitHub Enterprise Server 的公共和私有存储库。有关更多信息，请参阅 <a href="https://docs.github.com/en/get-started/learning-about-github/githubs-plans">GitHub 的计划</a>。</p><p>GitHub Pages 现在使用 GitHub Actions 来执行 Jekyll 构建。使用分支作为构建的源时，如果要使用内置的 Jekyll 工作流程，则必须在存储库中启用 GitHub Actions。或者，如果 GitHub Actions 不可用或已禁用，则将文件添加到源分支的根目录将绕过 Jekyll 构建过程并直接部署内容。有关启用 GitHub Actions 的更多信息，请参阅<a href="https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository">管理仓库的 GitHub Actions 设置</a>。<code>.nojekyll</code></p><h2 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h2><ul><li>介绍</li><li>创建您的网站</li><li>更改标题和描述</li><li>后续步骤</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><a href="https://docs.github.com/en/pages/quickstart#introduction">介绍</a></h2><p>在本指南中，您将在 上创建一个用户站点。<code>&lt;username&gt;.github.io</code></p><h2 id="创建您的网站"><a href="#创建您的网站" class="headerlink" title="创建您的网站"></a><a href="https://docs.github.com/en/pages/quickstart#creating-your-website">创建您的网站</a></h2><ol><li><p>在任何页面的右上角，选择 ，然后单击 <strong>New repository （新建存储库</strong>）。</p><p><img src="https://docs.github.com/assets/cb-29762/images/help/repository/repo-create-global-nav-update.png" alt="Screenshot of a GitHub dropdown menu showing options to create new items. The menu item &quot;New repository&quot; is outlined in dark orange."></p></li><li><p>输入 作为存储库名称。替换为您的 GitHub 用户名。例如，如果您的用户名是 ，则存储库名称应为 。<code>username.github.io``username``octocat``octocat.github.io</code></p><p><img src="https://docs.github.com/assets/cb-48480/images/help/pages/create-repository-name-pages.png" alt="Screenshot of GitHub Pages settings in a repository. The repository name field contains the text &quot;octocat.github.io&quot; and is outlined in dark orange."></p></li><li><p>选择仓库可见性。有关更多信息，请参阅<a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/about-repositories#about-repository-visibility">关于存储库</a>。</p></li><li><p>选择 <strong>Initialize this repository with a README。</strong></p></li><li><p>单击 <strong>Create repository（创建存储库</strong>）。</p></li><li><p>在仓库名称下，单击<strong>设置</strong>.如果您看不到“设置”选项卡，请选择下拉菜单，然后单击 <strong>Settings（设置</strong>）。</p><p><img src="https://docs.github.com/assets/cb-28260/images/help/repository/repo-actions-settings.png" alt="Screenshot of a repository header showing the tabs. The &quot;Settings&quot; tab is highlighted by a dark orange outline."></p></li><li><p>在边栏的“Code and automation（代码和自动化）”部分中，单击<strong>页面</strong>.</p></li><li><p>在“Build and deployment（构建和部署）”下的“Source（源）”下，选择 <strong>Deploy from a branch（从分支部署</strong>）。</p></li><li><p>在“Build and deployment（构建和部署）”下的“Branch（分支）”下，使用分支下拉菜单并选择发布源。</p><p><img src="https://docs.github.com/assets/cb-47265/images/help/pages/publishing-source-drop-down.png" alt="Screenshot of Pages settings in a GitHub repository. A menu to select a branch for a publishing source, labeled &quot;None,&quot; is outlined in dark orange."></p></li><li><p>（可选）打开存储库的文件。该文件是您为站点编写内容的位置。您可以编辑文件或暂时保留默认内容。<code>README.md``README.md</code></p></li><li><p>访问 查看您的新网站。请注意，将更改推送到 GitHub 后，最多可能需要 10 分钟才能发布对站点的更改。<code>username.github.io</code></p></li></ol><h2 id="更改标题和描述"><a href="#更改标题和描述" class="headerlink" title="更改标题和描述"></a><a href="https://docs.github.com/en/pages/quickstart#changing-the-title-and-description">更改标题和描述</a></h2><p>默认情况下，您网站的标题为 。您可以通过编辑仓库中的文件来更改标题。您还可以为站点添加描述。<code>username.github.io``_config.yml</code></p><ol><li><p>单击存储库的 <strong>Code （代码</strong>） 选项卡。</p></li><li><p>在文件列表中，单击以打开文件。<code>_config.yml</code></p></li><li><p>单击以编辑文件。</p></li><li><p>该文件已包含一行，用于指定站点的主题。添加一行新行，后跟所需的标题。添加一行新行，后跟所需的描述。例如：<code>_config.yml``title:``description:</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">jekyll-theme-minimal</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Octocat&#x27;s</span> <span class="string">homepage</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">Bookmark</span> <span class="string">this</span> <span class="string">to</span> <span class="string">keep</span> <span class="string">an</span> <span class="string">eye</span> <span class="string">on</span> <span class="string">my</span> <span class="string">project</span> <span class="string">updates!</span></span><br></pre></td></tr></table></figure></li><li><p>编辑完文件后，单击 <strong>Commit changes（提交更改</strong>）。</p></li></ol><h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a><a href="https://docs.github.com/en/pages/quickstart#next-steps">后续步骤</a></h2><p>您已经成功创建、个性化和发布了您的第一个 GitHub Pages 网站，但还有更多内容需要探索！以下是一些有用的资源，可帮助您使用 GitHub Pages 进行下一步作：</p><ul><li><a href="https://docs.github.com/en/pages/setting-up-a-github-pages-site-with-jekyll/adding-content-to-your-github-pages-site-using-jekyll#about-content-in-jekyll-sites">使用 Jekyll 向 GitHub Pages 站点添加内容</a>：本指南介绍如何向站点添加其他页面。</li><li><a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site">为 GitHub Pages 站点配置自定义域</a>：您可以在 GitHub 的域或您自己的自定义域上托管您的站点。<code>github.io</code></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2025/04/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2025/04/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>##第一章</p><p>内容</p><hr><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>第二章</p><p>内容</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/04/26/hello-world/"/>
      <url>/2025/04/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
