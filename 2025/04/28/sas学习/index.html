<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>sas学习 | gdh分享园</title><meta name="author" content="gdh"><meta name="copyright" content="gdh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="SAS系统学习： &#96; 123@Column&#96; 注解通常用于 ORM（对象关系映射）框架中，如 Hibernate 或 JPA（Java Persistence API），它用于指定 Java 类中的字段或属性如何映射到数据库表中的列。&#96;@ExcelProperty&#96; 注解通常用于 Excel 导入导出相关的框架中，它用于标记 Java 类中的字段或属性，以指定该字段或属性在 Excel 文">
<meta property="og:type" content="article">
<meta property="og:title" content="sas学习">
<meta property="og:url" content="http://gdhgxd.cn/2025/04/28/sas%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="gdh分享园">
<meta property="og:description" content="SAS系统学习： &#96; 123@Column&#96; 注解通常用于 ORM（对象关系映射）框架中，如 Hibernate 或 JPA（Java Persistence API），它用于指定 Java 类中的字段或属性如何映射到数据库表中的列。&#96;@ExcelProperty&#96; 注解通常用于 Excel 导入导出相关的框架中，它用于标记 Java 类中的字段或属性，以指定该字段或属性在 Excel 文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://gdhgxd.cn/img/fengdan.png">
<meta property="article:published_time" content="2025-04-28T08:58:00.000Z">
<meta property="article:modified_time" content="2025-04-28T08:58:00.000Z">
<meta property="article:author" content="gdh">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://gdhgxd.cn/img/fengdan.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "sas学习",
  "url": "http://gdhgxd.cn/2025/04/28/sas%E5%AD%A6%E4%B9%A0/",
  "image": "http://gdhgxd.cn/img/fengdan.png",
  "datePublished": "2025-04-28T08:58:00.000Z",
  "dateModified": "2025-04-28T08:58:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "gdh",
      "url": "http://gdhgxd.cn/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/keli.jpg"><link rel="canonical" href="http://gdhgxd.cn/2025/04/28/sas%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'sas学习',
  isHighlightShrink: true,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/fengdan.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">gdh分享园</span></a><a class="nav-page-title" href="/"><span class="site-name">sas学习</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">sas学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-28T08:58:00.000Z" title="发表于 2025-04-28 16:58:00">2025-04-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-28T08:58:00.000Z" title="更新于 2025-04-28 16:58:00">2025-04-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">15.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-04-28 16:58:00&quot;}" hidden></div><p>SAS系统学习：</p>
<p>&#96;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Column` 注解通常用于 ORM（对象关系映射）框架中，如 Hibernate 或 JPA（Java Persistence API），它用于指定 Java 类中的字段或属性如何映射到数据库表中的列。</span><br><span class="line"></span><br><span class="line">`@ExcelProperty` 注解通常用于 Excel 导入导出相关的框架中，它用于标记 Java 类中的字段或属性，以指定该字段或属性在 Excel 文件中的列名。</span><br></pre></td></tr></table></figure>



<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul>
<li><strong>Excel 导入导出</strong>：当你需要从 Excel 文件中读取数据或将数据写入 Excel 文件时，使用 <code>@ExcelProperty</code> 注解。</li>
<li><strong>数据库持久化</strong>：当你需要将 Java 对象映射到数据库表时，使用 <code>@Column</code> 注解。</li>
</ul>
<h4 id="ElementType-枚举值："><a href="#ElementType-枚举值：" class="headerlink" title="ElementType 枚举值："></a><code>ElementType</code> 枚举值：</h4><ul>
<li><code>METHOD</code>：表示注解可以应用于方法。</li>
<li><code>FIELD</code>：表示注解可以应用于字段（成员变量）。</li>
<li><code>TYPE</code>：表示注解可以应用于类、接口或枚举。</li>
<li><code>PARAMETER</code>：表示注解可以应用于方法参数。</li>
<li><code>CONSTRUCTOR</code>：表示注解可以应用于构造函数。</li>
<li><code>LOCAL_VARIABLE</code>：表示注解可以应用于局部变量。</li>
<li><code>ANNOTATION_TYPE</code>：表示注解可以应用于其他注解。</li>
<li><code>PACKAGE</code>：表示注解可以应用于包。</li>
</ul>
<p>@Target 用于指定注解可以应用于哪些程序元素。程序元素可以是类、方法、字段、构造函数等。@Target 元注解接受一个或多个 ElementType 枚举值作为参数，这些枚举值指定了注解可以应用于哪些类型的程序元素。</p>
<p><code>@Retention</code> 用于指定注解的生命周期。生命周期决定了注解在编译时和运行时的存在情况。<code>@Retention</code> 元注解接受一个 <code>RetentionPolicy</code> 枚举值作为参数。</p>
<ul>
<li><strong><code>@Target</code></strong>：用于指定注解可以应用于哪些类型的程序元素。</li>
<li><strong><code>@Retention</code></strong>：用于指定注解的生命周期，决定注解在编译时和运行时的存在情况。</li>
</ul>
<p>ORM（Object-Relational Mapping，对象关系映射）框架是一种编程技术，用于将对象模型中的对象与关系数据库中的表进行映射。ORM 框架的主要目的是简化数据库操作，使得开发者可以使用面向对象的方式来进行数据库交互，而不需要直接编写 SQL 语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import javax.persistence.*;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;users&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;username&quot;)</span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;email&quot;)</span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">    // 构造函数、getter 和 setter 省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Navicat 中，你可以通过 SQL 查询来格式化数据库表中某一列的数据。如果你想在查询结果中保留两位小数，可以使用 SQL 的 <code>FORMAT</code> 函数或者其他相关函数来实现这一点。</p>
<p>类似如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, FORMAT(column_name, 2) AS formatted_column</span><br><span class="line">FROM your_table;</span><br><span class="line">查看操作结果</span><br><span class="line">SELECT id, name, FORMAT(column_name, 2) AS formatted_column</span><br><span class="line">FROM your_table;</span><br><span class="line">永久格式化</span><br><span class="line">UPDATE your_table</span><br><span class="line">SET column_name = ROUND(column_name, 2);</span><br></pre></td></tr></table></figure>

<h3 id="BaseMapper-接口中定义的方法"><a href="#BaseMapper-接口中定义的方法" class="headerlink" title="BaseMapper&lt;T&gt; 接口中定义的方法"></a><code>BaseMapper&lt;T&gt;</code> 接口中定义的方法</h3><p><code>BaseMapper&lt;T&gt;</code> 接口中通常定义了以下方法：</p>
<ol>
<li>增<ul>
<li><code>int insert(T entity);</code>：插入一条记录。</li>
</ul>
</li>
<li>删<ul>
<li><code>int deleteById(ID primaryKey);</code>：根据主键删除一条记录。</li>
<li><code>int deleteByMap(@Param(&quot;cm&quot;) Map&lt;String, Object&gt; columnMap);</code>：根据 map 对象删除记录。</li>
</ul>
</li>
<li>改<ul>
<li><code>int updateById(T entity);</code>：根据主键更新一条记录。</li>
<li><code>int update(T entity, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; updateWrapper);</code>：根据 where 条件更新记录。</li>
</ul>
</li>
<li>查<ul>
<li><code>List&lt;T&gt; selectList(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);</code>：根据条件查询记录列表。</li>
<li><code>T selectOne(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);</code>：根据条件查询单条记录。</li>
<li><code>IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);</code>：根据条件分页查询记录列表。</li>
</ul>
</li>
</ol>
<p>CRUD 操作指的是数据库中常见的四种基本操作：Create（创建）、Read（读取）、Update（更新）和Delete（删除）。这些操作是任何应用程序与数据库交互的基础。</p>
<p>格式化方法：</p>
<p><code>String.format</code> 方法可以方便地格式化字符串。</p>
<p><code>DecimalFormat</code> 类提供了更强大的格式化数字的功能，特别是对于固定的小数点位数。</p>
<h1 id="MS的学习"><a href="#MS的学习" class="headerlink" title="MS的学习"></a>MS的学习</h1><p><code>append</code> 方法在 <code>StringBuffer</code> 类中用于将指定的内容追加到当前字符串的末尾。</p>
<p><code>trim</code> 方法是 <code>String</code> 类中的一个常用方法，用于去除字符串两端的空白字符。空白字符包括空格、制表符、换行符等。使用 <code>trim</code> 方法可以确保字符串在进行比较或拼接时不会因为两端的空白字符而产生意外的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * </span><br><span class="line">	 * TODO 获取考官信息加载到前台动态数据表格中</span><br><span class="line">	 * .本方法由 chenluwei 创建于 2019年11月13日上午10:27:36</span><br><span class="line">	 * @param page</span><br><span class="line">	 * @param limit</span><br><span class="line">	 * @param basicMng</span><br><span class="line">	 * @param pTitle</span><br><span class="line">	 * @param job</span><br><span class="line">	 * @return Map&lt;String,Object&gt;</span><br><span class="line">	 *</span><br><span class="line">	 */</span><br><span class="line">	@RequestMapping(&quot;getExaminerList&quot;)</span><br><span class="line">	@ResponseBody</span><br><span class="line">	public Map&lt;String, Object&gt; getExaminerList(int page, int limit, String basicMng, String pTitle, String job, Integer subjectId, Integer majorId) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();</span><br><span class="line">		StringBuffer where = new StringBuffer();</span><br><span class="line">		if (null != basicMng &amp;&amp; !&quot;&quot;.equals(basicMng)) &#123;</span><br><span class="line">			where.append(&quot;( ms_examiner.`name` like &#x27;%&quot; + basicMng.trim() + &quot;%&#x27; or ms_examiner.mbPhone = &#x27;&quot; + basicMng.trim() + &quot;&#x27;) and &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (null != pTitle &amp;&amp; !&quot;&quot;.equals(pTitle)) &#123;</span><br><span class="line">			where.append(&quot; ms_examiner.pTitle = &#x27;&quot; + pTitle.trim() + &quot;&#x27; and &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (null != job &amp;&amp; !&quot;&quot;.equals(job)) &#123;</span><br><span class="line">			where.append(&quot; ms_examiner.job = &#x27;&quot; + job.trim() + &quot;&#x27; and &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (null != subjectId) &#123;</span><br><span class="line">			where.append(&quot; ms_examiner.subjectId = &#x27;&quot; + subjectId + &quot;&#x27; and &quot;);</span><br><span class="line">			if (null != majorId) &#123;</span><br><span class="line">				where.append(&quot; ms_examiner.majorId = &#x27;&quot; + majorId + &quot;&#x27; and &quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		where.append(&quot; 1=1 &quot;);</span><br><span class="line">		Page findByPage = this.examinerService.findByPageByLeftJoin(ExaminerVO.class, page, limit, where.toString(), null);</span><br><span class="line">		result.put(&quot;code&quot;, 0);</span><br><span class="line">		result.put(&quot;msg&quot;, &quot;&quot;);</span><br><span class="line">		result.put(&quot;count&quot;, findByPage.getMaxRowCount());</span><br><span class="line">		result.put(&quot;data&quot;, findByPage.getResultList());</span><br><span class="line">		logOperation(&quot;加载考官数据&quot;, OperationType.AJAX_LOAD, true);</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>where.append(“( ms_examiner.name like ‘%” + basicMng.trim() + “%’ or ms_examiner.mbPhone &#x3D; ‘“ + basicMng.trim() + “‘) and “);</p>
<p>这一行代码构建了一个SQL查询条件，具体如下：ms_examiner.namelike ‘% + basicMng.trim() + %’”：这部分表示考官的姓名中包含basicMng的值。</p>
<p>%是SQL中的通配符，表示任意字符序列。因此，like ‘%value%’表示字段中包含value的任何字符串。</p>
<p>or ms_examiner.mbPhone &#x3D; ‘ + basicMng.trim() + ‘：这部分表示考官的手机号等于basicMng的值。</p>
<p>( 和 )：括号用于将两个条件组合在一起，形成一个复合条件。</p>
<p>and：在SQL查询中，and用于连接多个条件。</p>
<p>where.append(“ 1&#x3D;1 “);作用是在所有条件之后追加 <code>1=1</code>。这是一个恒为真的条件，确保即使没有其他条件时，SQL 查询也不会因为 WHERE 子句为空而报错。</p>
<p>logOperation: 调用日志记录方法，记录当前的操作。</p>
<p>where.toString(): 将构建好的查询条件字符串传递给方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RegisterMapper</span><br><span class="line">public interface DeleteByPrimaryKeyMapper&lt;T&gt; &#123;</span><br><span class="line">    @DeleteProvider(</span><br><span class="line">        type = BaseDeleteProvider.class,</span><br><span class="line">        method = &quot;dynamicSQL&quot;</span><br><span class="line">    )</span><br><span class="line">    int deleteByPrimaryKey(Object var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@RegisterMapper 是MyBatis的注解，用于注册映射器接口。这意味着MyBatis会自动扫描并注册带有此注解的接口，使其可以在应用程序中使用。</p>
<p>@DeleteProvider 是MyBatis的注解，用于指定动态SQL的提供者类和方法。</p>
<p>type &#x3D; BaseDeleteProvider.class指定了提供动态SQL的类是 <code>BaseDeleteProvider</code>。        method &#x3D; “dynamicSQL”指定了在 <code>BaseDeleteProvider</code> 类中生成动态SQL的方法名是 <code>dynamicSQL</code>|</p>
<h2 id="工具类作用"><a href="#工具类作用" class="headerlink" title="工具类作用"></a>工具类作用</h2><p><code>AssertUtil</code> 类是一个工具类，提供了多种方法来检查和比较对象的状态。这些方法在开发中非常有用，可以帮助开发者快速判断对象是否为空、集合是否为空、字符串是否为空等，以及比较两个对象的属性值是否相等。</p>
<p><code>Base64Util</code> 类是一个工具类，用于将图片文件转换为 Base64 编码的字符串。这个类的主要功能是读取图片文件的内容，并将其编码为 Base64 字符串。</p>
<p><code>BaseController</code> 类是一个工具类，主要用于在 Spring MVC 应用程序中获取 <code>HttpServletRequest</code>、<code>HttpServletResponse</code>、<code>HttpSession</code> 和 <code>ServletContext</code> 等对象</p>
<p><code>ClassType</code> 类是一个工具类，用于定义一些常用的 Java 类型常量。这些常量可以在其他类中引用，以便于类型检查和转换</p>
<p><code>Serializable</code> 接口是 Java 标准库中的一个接口，位于 <code>java.io</code> 包中。这个接口的主要目的是标记一个类的对象可以被序列化，即可以将其状态转换为字节流，以便于存储或传输。</p>
<h2 id="服务器网络判断"><a href="#服务器网络判断" class="headerlink" title="服务器网络判断"></a>服务器网络判断</h2><ol>
<li>检查是否有网络连接：首先需要确保服务器本身是否有正常的网络连接。可以通过ping命令或者使用网络监测工具来测试服务器是否可以与其他设备进行通信。</li>
<li>检查服务器网络配置：确认服务器的IP地址、子网掩码、网关等网络配置是否正确。可以通过查看服务器的网络设置或者执行ipconfig（Windows）或ifconfig（Linux）命令来获取相关信息。</li>
<li>检查服务器是否能够访问互联网：使用浏览器或者命令行工具（如curl或wget）尝试访问互联网上的一些常见网站，以确认服务器是否能够正常访问外部网络。如果无法访问，可能是防火墙或路由器设置问题。</li>
<li>检查本地网络设备：如果服务器连接到本地网络，需要检查与服务器相连的交换机、路由器等网络设备的状态。检查是否有物理连接问题、端口是否正常工作，以及设备的配置是否正确。</li>
<li>检查网络负载和带宽：如果服务器的网络访问速度较慢或者出现丢包现象，可能是网络负载过高或者带宽不足。可以通过网络监测工具或者流量分析工具来检测服务器的网络负载情况，以及网络带宽的使用情况。</li>
<li>检查防火墙设置：如果服务器安装了防火墙软件或配置了网络访问限制规则，可以检查防火墙的设置，确保访问规则没有阻止服务器对外部网络的访问。</li>
<li>联系网络服务提供商：如果以上步骤都没有找到问题，可以与服务器所在的数据中心或网络服务提供商联系，跟他们反映问题，并请他们协助解决。</li>
</ol>
<h1 id="java面试准备"><a href="#java面试准备" class="headerlink" title="java面试准备:"></a>java面试准备:</h1><h2 id="redis篇"><a href="#redis篇" class="headerlink" title="redis篇"></a>redis篇</h2><h3 id="最近的项目中那些使用了redis？"><a href="#最近的项目中那些使用了redis？" class="headerlink" title="最近的项目中那些使用了redis？"></a>最近的项目中那些使用了redis？</h3><p>结合项目，一是验证项目场景的真实性，二是做为深入发问的切入点。</p>
<p>缓存：缓存3兄弟（穿透，击穿，雪崩），双写一致，持久化，数据过期测试，数据淘汰策略</p>
<p>分布式锁：setnx,redisson</p>
<p>消息队列，延迟队列：何种数据类型</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>查询一个不存在的数据，MySQL查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库。数据访问过多，数据库宕机</p>
<h5 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h5><p>缓存空数据</p>
<h5 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h5><p>布隆过滤器：可以检索一个元素是否在一个集合中。</p>
<p>会有误判，所以需要误判率。</p>
<p>误判率：数组越小误判率越大，数组越大误判率越小，但内存使用</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些并发请求可能会瞬间把DB压垮</p>
<h5 id="解决方案一-1"><a href="#解决方案一-1" class="headerlink" title="解决方案一"></a>解决方案一</h5><p>互斥锁，强一致，性能差（业务范围与钱相关）</p>
<h5 id="解决方案二-1"><a href="#解决方案二-1" class="headerlink" title="解决方案二"></a>解决方案二</h5><p>逻辑过期，高可用，性能优，不能保证数据绝对一致</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>是指在同一时段大量的缓存key同时失效或者redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>给不同的key的ttl添加随机值</p>
<p>利用redis集群提高服务的可用性</p>
<p>给缓存业务添加降级限流策略</p>
<p>给业务添加多级缓存</p>
<p>穿透无中生有key，布隆过滤null隔离。</p>
<p>缓存击穿过期key，锁与非器解难题。</p>
<p>雪崩大量过期key，过期时间要随机。</p>
<p>面试必考3兄弟，可用限流来保底。</p>
<p>redis作为缓存，mysql的数据如何与redis进行同步呢？双写一致性</p>
<p>设置前提，业务背景。</p>
<h2 id="docker学习"><a href="#docker学习" class="headerlink" title="docker学习"></a>docker学习</h2><p>什么是docker，docker就是一个快速交付应用，运行应用的技术。</p>
<p>可以将程序及其依赖，运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统，运行时利用沙箱机制形成隔离容器，各个应用互不干扰。</p>
<h3 id="项目部署问题"><a href="#项目部署问题" class="headerlink" title="项目部署问题"></a>项目部署问题</h3><p>大型项目组件较多，运行环境较为复杂，部署时会碰到一些问题：</p>
<p>依赖关系复杂，容易产生兼容性问题</p>
<p>开发，测试，生产环境有差异</p>
<p>docker如何解决依赖的兼容问题的？</p>
<p>将应用的Libs（函数库），Deps（依赖），配置与应用一起打包</p>
<p>将每个应用放到一个隔离容器去运行，避免相互干扰</p>
<p>不同环境操作系统不同，docker怎么解决？</p>
<p>docker将用户程序与所调用的系统（比如Ubuntu）函数库一起打包</p>
<p>docker运行到不同操作系统时，直接基于打包的库函数，借助于操作系统的Linux内核来运行。</p>
<p>虚拟机是操作系统中模拟硬件设备，然后运行另一个操作系统。</p>
<p>docker架构</p>
<p>docker是一个cs架构的程序，由两部分组成：</p>
<p>服务端：docker守护进程，负责处理docker指令，管理镜像，容器等。</p>
<p>客服端：通过命令或restAPI向docker服务端发送指令。可以在本地或远程服务端发送指令。</p>
<h4 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h4><p>卸载旧版本docker</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">					docker-client \</span><br><span class="line">					docker-client-latest \</span><br><span class="line">					docker-common \</span><br><span class="line">					docker-latest \</span><br><span class="line">					docker-latest-logrotate \</span><br><span class="line">					docker-logrotate \</span><br><span class="line">					docker-selinux \</span><br><span class="line">					docker-engine-selinux \</span><br><span class="line">					docker-engine \</span><br><span class="line">					docker-ce</span><br></pre></td></tr></table></figure>

<h4 id="安装yum工具："><a href="#安装yum工具：" class="headerlink" title="安装yum工具："></a>安装yum工具：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">			device-mapper-persistent-data \</span><br><span class="line">			lvm2 --skip-borken</span><br></pre></td></tr></table></figure>

<h4 id="更新镜像源："><a href="#更新镜像源：" class="headerlink" title="更新镜像源："></a>更新镜像源：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更新为阿里云镜像源</span><br></pre></td></tr></table></figure>

<h4 id="输入命令"><a href="#输入命令" class="headerlink" title="输入命令"></a>输入命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install y docker-ce //docker-ce为社区免费版本。</span><br></pre></td></tr></table></figure>



<p>启动docker需要关闭防火墙。</p>
<p>关闭防火墙：systemctl stop firewalld</p>
<p>systemctl disable firewalld</p>
<p>启动docker：</p>
<p>systemctl start docker</p>
<p>查看是否成功dockers -v查看版本。</p>
<h2 id="docker基本操作"><a href="#docker基本操作" class="headerlink" title="docker基本操作"></a>docker基本操作</h2><p>镜像相关命令</p>
<p>镜像名称一般分为两部分组成:[repository]:[tag]</p>
<p>在没有指定tag时，默认是latest，代表最新版本的镜像</p>
<p>docker build 构建镜像</p>
<p>docker imges 查看镜像</p>
<p>docker rmi 删除镜像</p>
<p>docker pull 从服务拉取镜像</p>
<p>docker push 推送镜像到服务</p>
<p>docker save 压缩</p>
<p>docker load 解压 </p>
<p>  容器相关命令</p>
<p>docker run 运行</p>
<p>docker exec 进入容器</p>
<p>docker logs 查看容器运行日志</p>
<p>docker ps 查看所有和运行的容器</p>
<p>docker rm 删除指定容器</p>
<p>docker pause暂停</p>
<p>docker unpause </p>
<p>docker start </p>
<p>docker stop 停止</p>
<h4 id="创建运行一个nginx容器"><a href="#创建运行一个nginx容器" class="headerlink" title="创建运行一个nginx容器"></a>创建运行一个nginx容器</h4><p>步骤一：取dockerhub上查看nginx的容器运行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>

<p>docker run : 创建并运行一个容器</p>
<p>–name: 给容器起一个名字，比如叫做mn</p>
<p>-p: 将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</p>
<p>-d： 后台运行容器</p>
<p>nginx：镜像名称</p>
<h4 id="进入容器内部，修改HTML文件内容"><a href="#进入容器内部，修改HTML文件内容" class="headerlink" title="进入容器内部，修改HTML文件内容"></a>进入容器内部，修改HTML文件内容</h4><p>步骤一：进入容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mn bash</span><br></pre></td></tr></table></figure>

<p>docker exec ：进入容器内部，执行一个命令</p>
<p>-it： 给当前进入的容器创建一个标准输入，输出终端，允许我们与容器交互</p>
<p>mn：要进入的容器的名称</p>
<p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p>
<h4 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h4><p>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>
<p>容器与数据耦合的问题</p>
<p>不便于修改</p>
<p>数据不可复用</p>
<p>升级维护困难</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure>

<p>create 创建一个volume</p>
<p>inspect 显示一个或多个volume的信息</p>
<p>Ls	列出所有的volume</p>
<p>prune 删除未使用的volume</p>
<p>rm 删除一个或多个指定的volume</p>
<h1 id="微服务学习"><a href="#微服务学习" class="headerlink" title="微服务学习"></a>微服务学习</h1><h2 id="eureka框架"><a href="#eureka框架" class="headerlink" title="eureka框架"></a>eureka框架</h2><p>微服务角色有两类：</p>
<h3 id="EurekaServer：服务端，注册中心"><a href="#EurekaServer：服务端，注册中心" class="headerlink" title="EurekaServer：服务端，注册中心"></a>EurekaServer：服务端，注册中心</h3><p>记录服务信息</p>
<p>心跳监控：发送http请求</p>
<h3 id="EurekaClient：客服端"><a href="#EurekaClient：客服端" class="headerlink" title="EurekaClient：客服端"></a>EurekaClient：客服端</h3><p>服务提供者：注册自己的信息到EurekaServer</p>
<p>每隔30秒发送心跳，即发送http请求</p>
<p>服务消费者：根据服务名称从EurekaServer拉取服务列表</p>
<p>基于服务列表做负载均衡，选中一个微服务后发起远程调用 </p>
<p>搭建注册中心》服务注册》服务发现</p>
<p>依赖注入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- eureka服务端 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.18.30&lt;/version&gt; &lt;!-- 使用最新版本 --&gt;</span><br><span class="line">           &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>.yml文件修改:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 10086 # 服务端口</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eurekaserver # eureka的服务名称</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:  # eureka的地址信息</span><br><span class="line">      defaultZone: http://127.0.0.1:10086/eureka</span><br></pre></td></tr></table></figure>

<p>restTemplate修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;http://userservice/user/&quot; + order.getUserId();</span><br><span class="line">//这里把具体的网络端口改成userservice</span><br><span class="line">//加入注解@LoadBalanced</span><br><span class="line">@LoadBalanced</span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="调整负载均衡规则："><a href="#调整负载均衡规则：" class="headerlink" title="调整负载均衡规则："></a>调整负载均衡规则：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">Public IRule randomRule&#123;</span><br><span class="line">	return new randomRule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用全局。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userservice:</span><br><span class="line">	ribbon:</span><br><span class="line">		NFLoadBalancerRuleClassName: com.netflix.loadbalaner.RandomRule</span><br></pre></td></tr></table></figure>

<p>作用服务器。局部作用</p>
<h2 id="springMvc"><a href="#springMvc" class="headerlink" title="springMvc"></a>springMvc</h2><p>入门案例</p>
<p>报错解决：</p>
<p>[ERROR] Failed to execute goal <em>org.apache.maven.plugins:maven-resources-plugin:3.3.0:resources</em> (default-resources) on project springmvc_01_quickstart: Execution default-resources of goal org.apache.maven.plugins:maven-resources-plugin:3.3.0:resources failed: Unable to load the mojo ‘resources’ (or one of its required components) from the plugin ‘org.apache.maven.plugins:maven-resources-plugin:3.3.0’: com.google.inject.ProvisionException: Unable to provision, see the following errors: [ERROR]</p>
<p>解决加入插件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.3.1&lt;/version&gt; &lt;!-- 使用最新版本 --&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>springmvc主要进行处理请求的控制器类，定义处理请求的控制器方法，并配置映射路径与返回json数据。</p>
<p>流程：</p>
<p>容器初始化：</p>
<p>1.服务器启动，指向servletContainersInitConfig类，初始化web容器</p>
<p>2.指向createServletApplicationContext方法，创建了WebApplicationContext对象</p>
<p>3.加载SpringMvcConfig</p>
<p>4.执行@ComponenScan加载对应的bean</p>
<p>5.加载userController，每个@RequestMapping的名称对应一个具体的方法</p>
<p>6.执行getServletMappings方法，定义所有的请求都通过SpringMVC</p>
<p>单次请求过程</p>
<p>1.发送请求Localhost&#x2F;save</p>
<p>2.web容器发现所有请求都经过springMvc，将请求交给springMvc处理</p>
<p>3.解析请求路径&#x2F;save</p>
<p>4.由&#x2F;save匹配执行对应的方法save</p>
<p>5.执行save</p>
<p>6检测到有@ResponseBody直接将save方法的返回值作为响应请求体返回给请求方</p>
<h3 id="因为功能不同，如何避免spring错误的加载到springMvc的bean？"><a href="#因为功能不同，如何避免spring错误的加载到springMvc的bean？" class="headerlink" title="因为功能不同，如何避免spring错误的加载到springMvc的bean？"></a>因为功能不同，如何避免spring错误的加载到springMvc的bean？</h3><p>加载spring控制的bean的时候排除掉springmvc控制的bean。</p>
<p>方式1：spring加载的bean设定扫描范围为com.itheima.排除掉controller包内的bean。</p>
<p>方式2：spring扫描设为精准范围。</p>
<p>@ComponentScan</p>
<p>类型：类注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(vale = &quot;com.itheima&quot;,</span><br><span class="line">@ComponentScan.Filter(</span><br><span class="line">type = FilterType.ANNOTATION,</span><br><span class="line">classes = Controller.class))</span><br><span class="line"></span><br><span class="line">public class SpringConfig&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>excludeFilters:排除扫描路径中加载的bean，需要指定类别和具体项。</p>
<p>includeFilters：加载指定的bean，需要指定类别和具体项</p>
<h3 id="Spring-Boot-解决-Spring-与-Spring-MVC-的-Bean-扫描问题"><a href="#Spring-Boot-解决-Spring-与-Spring-MVC-的-Bean-扫描问题" class="headerlink" title="Spring Boot 解决 Spring 与 Spring MVC 的 Bean 扫描问题"></a>Spring Boot 解决 Spring 与 Spring MVC 的 Bean 扫描问题</h3><p>Spring Boot 通过自动配置机制巧妙地解决了传统 Spring 和 Spring MVC 应用中可能出现的 Bean 扫描冲突问题。以下是其解决方案的核心要点：</p>
<h4 id="1-自动配置与组件扫描分离"><a href="#1-自动配置与组件扫描分离" class="headerlink" title="1. 自动配置与组件扫描分离"></a>1. 自动配置与组件扫描分离</h4><p>Spring Boot 使用 <code>@SpringBootApplication</code> 注解（组合了 <code>@Configuration</code>, <code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>）来启动应用，其中：</p>
<ul>
<li><code>@ComponentScan</code> 默认扫描主类所在包及其子包</li>
<li><code>@EnableAutoConfiguration</code> 负责加载 Spring Boot 提供的自动配置</li>
</ul>
<h4 id="2-区分-Web-和非-Web-配置"><a href="#2-区分-Web-和非-Web-配置" class="headerlink" title="2. 区分 Web 和非 Web 配置"></a>2. 区分 Web 和非 Web 配置</h4><p>Spring Boot 自动配置会检测应用是否是 Web 应用，并相应配置：</p>
<ul>
<li>对于 Web 应用，会自动配置 <code>DispatcherServlet</code> 和相关的 MVC 组件</li>
<li>非 Web 应用则不会加载这些配置</li>
</ul>
<h4 id="3-内部实现机制"><a href="#3-内部实现机制" class="headerlink" title="3. 内部实现机制"></a>3. 内部实现机制</h4><p>具体来说，Spring Boot 通过以下方式解决扫描问题：</p>
<ol>
<li><p><strong>父子容器结构</strong>：传统 Spring MVC 使用父子容器，而 Spring Boot 默认使用单一容器</p>
<ul>
<li><p>子容器可以访问父容器的 Bean，但父容器不能访问子容器的 Bean</p>
</li>
<li><p>父容器：通常包含服务层、数据层等 Bean</p>
</li>
<li><p>子容器：包含控制器、视图解析器等 MVC 相关 Bean</p>
</li>
<li><p>Spring Boot 2.x 之后默认使用单一容器简化了这种结构</p>
</li>
</ul>
</li>
<li><p><strong>自动配置类条件过滤</strong>：</p>
<ul>
<li><code>WebMvcAutoConfiguration</code> 只在 Web 环境下生效</li>
<li>通过 <code>@ConditionalOnWebApplication</code> 等条件注解控制配置类的加载</li>
</ul>
</li>
<li><p><strong>组件扫描顺序控制</strong>：</p>
<ul>
<li>Spring Boot 确保核心组件先被扫描和初始化</li>
<li>MVC 相关组件随后加载</li>
</ul>
</li>
</ol>
<h4 id="4-自定义配置"><a href="#4-自定义配置" class="headerlink" title="4. 自定义配置"></a>4. 自定义配置</h4><p>如果需要更细粒度的控制，可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义 MVC 配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 非 Web 相关配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-避免冲突的最佳实践"><a href="#5-避免冲突的最佳实践" class="headerlink" title="5. 避免冲突的最佳实践"></a>5. 避免冲突的最佳实践</h4><ol>
<li>将主类放在项目根包中</li>
<li>避免使用 <code>@ComponentScan</code> 手动覆盖默认扫描路径</li>
<li>如果需要排除某些自动配置，使用 <code>@EnableAutoConfiguration(exclude = &#123;...&#125;)</code></li>
</ol>
<p>通过以上机制，Spring Boot 简化了传统 Spring MVC 中需要手动配置父子容器和重复扫描的问题，使开发者能够更专注于业务逻辑而非配置。</p>
<h3 id="pojo与json区别"><a href="#pojo与json区别" class="headerlink" title="pojo与json区别"></a>pojo与json区别</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">POJO</th>
<th align="left">JSON</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可读性</strong></td>
<td align="left">需要熟悉 Java 语法</td>
<td align="left">易于人类阅读和编写</td>
</tr>
<tr>
<td align="left"><strong>跨平台支持</strong></td>
<td align="left">仅限于 Java 环境</td>
<td align="left">支持所有编程语言</td>
</tr>
<tr>
<td align="left"><strong>数据类型支持</strong></td>
<td align="left">支持复杂的 Java 数据类型</td>
<td align="left">支持基本类型和简单结构</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">在 Java 中操作高效</td>
<td align="left">需要解析和序列化，性能较低</td>
</tr>
<tr>
<td align="left"><strong>用途</strong></td>
<td align="left">内部数据表示</td>
<td align="left">数据交换和存储</td>
</tr>
</tbody></table>
<p>ISO 日期格式遵循 <strong>ISO 8601</strong> 标准，这是一种国际标准化的日期和时间表示方法。</p>
<p>Pattern 是指一种自定义的日期格式模式，通常用于编程语言或工具中，用于定义日期的显示方式。</p>
<p>Rest风格是一张描述访问资源的形式，使用这种风格开发叫restful</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.POST)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@RequestBody</code></th>
<th align="left"><code>@RequestParam</code></th>
<th align="left"><code>@PathVariable</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据来源</strong></td>
<td align="left">请求体（Request Body）</td>
<td align="left">URL 查询参数（Query Params）</td>
<td align="left">URL 路径（Path Variables）</td>
</tr>
<tr>
<td align="left"><strong>适用请求方法</strong></td>
<td align="left">POST、PUT</td>
<td align="left">GET</td>
<td align="left">GET、POST、PUT、DELETE 等</td>
</tr>
<tr>
<td align="left"><strong>数据类型</strong></td>
<td align="left">复杂对象（如 JSON）</td>
<td align="left">简单键值对</td>
<td align="left">简单值（如 ID）</td>
</tr>
<tr>
<td align="left"><strong>示例 URL</strong></td>
<td align="left">无（数据在请求体中）</td>
<td align="left"><code>/users?name=John&amp;age=30</code></td>
<td align="left"><code>/users/123</code></td>
</tr>
<tr>
<td align="left"><strong>示例代码</strong></td>
<td align="left"><code>@RequestBody User user</code></td>
<td align="left"><code>@RequestParam String name</code></td>
<td align="left"><code>@PathVariable int id</code></td>
</tr>
</tbody></table>
<p>拦截器（Interceptor）和过滤器（Filter）的区别与相同点的表格展示：</p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>拦截器（Interceptor）</strong></th>
<th align="left"><strong>过滤器（Filter）</strong></th>
<th align="left"><strong>相同点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>作用范围</strong></td>
<td align="left">方法级别，通常用于AOP编程，拦截方法调用前后。</td>
<td align="left">请求和响应级别，作用于整个Web请求和响应的全局处理。</td>
<td align="left">都用于请求和响应的处理，增强应用程序功能。</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">Spring框架中的控制器方法拦截、RPC框架中的远程方法调用拦截。</td>
<td align="left">Java Web应用中的请求和响应处理（如Servlet过滤器）。</td>
<td align="left">都可以用于日志记录、安全控制、性能监控等。</td>
</tr>
<tr>
<td align="left"><strong>执行顺序</strong></td>
<td align="left">在Web应用中，拦截器的执行顺序在过滤器之后，因为过滤器先处理请求。</td>
<td align="left">在Web应用中，过滤器先于拦截器执行，因为它在请求到达Servlet之前进行处理。</td>
<td align="left">都遵循一定的执行顺序，且可以在请求处理链中协同工作。</td>
</tr>
<tr>
<td align="left"><strong>粒度</strong></td>
<td align="left">更细粒度，针对方法级别的拦截和控制。</td>
<td align="left">较粗粒度，针对整个请求和响应的全局处理。</td>
<td align="left">都可以对请求和响应进行干预，但粒度不同。</td>
</tr>
<tr>
<td align="left"><strong>实现框架</strong></td>
<td align="left">常见于Spring等AOP框架。</td>
<td align="left">常见于Java Web应用（如Servlet）。</td>
<td align="left">都是通过框架或容器提供的机制实现。</td>
</tr>
<tr>
<td align="left"><strong>典型功能</strong></td>
<td align="left">日志记录、权限验证、数据预处理、性能监控等。</td>
<td align="left">字符编码设置、响应压缩、安全控制（如身份验证）、日志记录等。</td>
<td align="left">功能上有重叠，例如日志记录和安全控制。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">适用于需要对方法调用过程进行精细化控制的场景。</td>
<td align="left">适用于需要对整个Web请求和响应进行全局处理的场景。</td>
<td align="left">都用于增强应用程序的功能，但适用场景不同。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">拦截器是Spring MVC框架的一部分，专门用于在控制器（Controller）方法执行前后进行拦截和处理。它的作用主要集中在<strong>控制器层面</strong>，能够对请求的处理过程进行更细粒度的控制。</td>
<td align="left">过滤器是Servlet规范的一部分，作用于Spring MVC之外，主要用于对<strong>HTTP请求和响应进行全局处理</strong>。它的作用范围比拦截器更广，通常在请求进入Spring MVC框架之前就已经开始工作。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="什么是代理？"><a href="#什么是代理？" class="headerlink" title="什么是代理？"></a>什么是代理？</h3><p>是一种设计模式，它允许通过一个代理对象来控制对另一个对象的访问。代理模式的核心思想是为目标对象提供一个代理，并由代理对象控制对目标对象的访问。</p>
<ol>
<li><p><strong>静态代理</strong>：</p>
<p>代理类和目标类实现相同的接口。</p>
<p>代理类在编译时就已经确定。</p>
</li>
<li><p><strong>动态代理</strong>：</p>
<p>代理类在运行时动态生成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">// 1. 定义接口</span><br><span class="line">interface Star &#123;</span><br><span class="line">    void sing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 创建目标类</span><br><span class="line">class BigStar implements Star &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sing() &#123;</span><br><span class="line">        System.out.println(&quot;大明星唱歌&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 创建动态代理</span><br><span class="line">class ProxyUtil &#123;</span><br><span class="line">    public static Star createProxy(Star target) &#123;</span><br><span class="line">        return (Star) Proxy.newProxyInstance(</span><br><span class="line">                ProxyUtil.class.getClassLoader(), // 类加载器</span><br><span class="line">                new Class[]&#123;Star.class&#125;, // 目标接口</span><br><span class="line">                new InvocationHandler() &#123; // 调用处理器</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        System.out.println(&quot;代理开始&quot;);</span><br><span class="line">                        Object result = method.invoke(target, args); // 调用目标方法</span><br><span class="line">                        System.out.println(&quot;代理结束&quot;);</span><br><span class="line">                        return result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试类</span><br><span class="line">public class DynamicProxyDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Star bigStar = new BigStar();</span><br><span class="line">        Star proxy = ProxyUtil.createProxy(bigStar);</span><br><span class="line">        proxy.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Proxy.newProxyInstance</code></strong>：</p>
<p>用于创建代理对象。</p>
<p>参数：</p>
<ol>
<li>类加载器（<code>ClassLoader</code>）。</li>
<li>目标接口数组（<code>Class&lt;?&gt;[]</code>）。</li>
<li>调用处理器（<code>InvocationHandler</code>）。</li>
</ol>
<p><strong><code>InvocationHandler.invoke</code></strong>：</p>
<p>在代理对象调用方法时执行。</p>
<p>参数：</p>
<ol>
<li>代理对象（<code>Object proxy</code>）。</li>
<li>调用的方法（<code>Method method</code>）。</li>
<li>方法参数（<code>Object[] args</code>）。</li>
</ol>
</li>
</ol>
<h3 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理?"></a>什么是代理?</h3><p>是 Java 提供的一种机制，允许程序在运行时动态地获取类的信息（如类名、方法、字段、构造函数等），并操作这些信息。通过反射，程序可以在运行时检查和修改对象的行为，甚至调用私有方法或访问私有字段。</p>
<h3 id="1-反射的核心功能"><a href="#1-反射的核心功能" class="headerlink" title="1. 反射的核心功能"></a>1. <strong>反射的核心功能</strong></h3><p>反射的主要功能包括：</p>
<ol>
<li><strong>获取类的信息</strong>：<ul>
<li>获取类的名称、修饰符、父类、接口、字段、方法、构造函数等。</li>
</ul>
</li>
<li><strong>创建对象</strong>：<ul>
<li>动态创建类的实例。</li>
</ul>
</li>
<li><strong>调用方法</strong>：<ul>
<li>动态调用对象的方法（包括私有方法）。</li>
</ul>
</li>
<li><strong>访问字段</strong>：<ul>
<li>动态获取或修改对象的字段值（包括私有字段）。</li>
</ul>
</li>
<li><strong>操作数组</strong>：<ul>
<li>动态创建和操作数组。</li>
</ul>
</li>
</ol>
<h3 id="2-反射的核心类"><a href="#2-反射的核心类" class="headerlink" title="2. 反射的核心类"></a>2. <strong>反射的核心类</strong></h3><p>Java 反射机制主要通过以下类和接口实现：</p>
<ol>
<li><strong><code>Class&lt;T&gt;</code></strong>：<ul>
<li>表示一个类或接口的类型信息。</li>
<li>可以通过 <code>Class.forName(&quot;类名&quot;)</code> 或 <code>对象.getClass()</code> 获取。</li>
</ul>
</li>
<li><strong><code>Field</code></strong>：<ul>
<li>表示类的字段（成员变量）。</li>
<li>可以通过 <code>Class.getField()</code> 或 <code>Class.getDeclaredField()</code> 获取。</li>
</ul>
</li>
<li><strong><code>Method</code></strong>：<ul>
<li>表示类的方法。</li>
<li>可以通过 <code>Class.getMethod()</code> 或 <code>Class.getDeclaredMethod()</code> 获取。</li>
</ul>
</li>
<li><strong><code>Constructor&lt;T&gt;</code></strong>：<ul>
<li>表示类的构造函数。</li>
<li>可以通过 <code>Class.getConstructor()</code> 或 <code>Class.getDeclaredConstructor()</code> 获取。</li>
</ul>
</li>
<li><strong><code>Modifier</code></strong>：<ul>
<li>提供对类、字段、方法等的修饰符（如 <code>public</code>、<code>private</code>、<code>static</code> 等）的解析。</li>
</ul>
</li>
</ol>
<h4 id="1-获取-Class-对象"><a href="#1-获取-Class-对象" class="headerlink" title="(1) 获取 Class 对象"></a>(1) <strong>获取 Class 对象</strong></h4><ul>
<li><p><strong><code>Class.forName(&quot;类名&quot;)</code></strong>：</p>
<ul>
<li>通过类的全限定名获取 <code>Class</code> 对象。</li>
</ul>
<p>java</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(&quot;java.util.ArrayList&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>对象.getClass()</code></strong>：</p>
<ul>
<li>通过对象获取 <code>Class</code> 对象。</li>
</ul>
<p>java</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello&quot;;</span><br><span class="line">Class&lt;?&gt; clazz = str.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>类名.class</code></strong>：</p>
<ul>
<li>通过类字面量获取 <code>Class</code> 对象。</li>
</ul>
<p>java</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = String.class;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-反射的优缺点"><a href="#5-反射的优缺点" class="headerlink" title="5. 反射的优缺点"></a>5. <strong>反射的优缺点</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>动态性</strong>：<ul>
<li>可以在运行时动态加载类、创建对象、调用方法等。</li>
</ul>
</li>
<li><strong>灵活性</strong>：<ul>
<li>可以操作私有字段和方法，突破访问限制。</li>
</ul>
</li>
<li><strong>通用性</strong>：<ul>
<li>适用于框架开发、动态代理、注解处理等场景。</li>
</ul>
</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>性能开销</strong>：<ul>
<li>反射操作比直接调用方法或访问字段慢，因为需要额外的类型检查和动态解析。</li>
</ul>
</li>
<li><strong>安全性问题</strong>：<ul>
<li>反射可以绕过访问控制（如访问私有字段和方法），可能导致安全问题。</li>
</ul>
</li>
<li><strong>代码复杂性</strong>：<ul>
<li>反射代码通常比普通代码更复杂，可读性和维护性较差。</li>
</ul>
</li>
</ol>
<h3 id="Spring-管理与方法调用的区别"><a href="#Spring-管理与方法调用的区别" class="headerlink" title="Spring 管理与方法调用的区别"></a><strong>Spring 管理与方法调用的区别</strong></h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Spring 管理</th>
<th align="left">方法调用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>对象创建</strong></td>
<td align="left">由 Spring 容器负责创建</td>
<td align="left">手动创建</td>
</tr>
<tr>
<td align="left"><strong>依赖注入</strong></td>
<td align="left">支持依赖注入（DI）</td>
<td align="left">不支持依赖注入</td>
</tr>
<tr>
<td align="left"><strong>生命周期管理</strong></td>
<td align="left">Spring 负责对象的初始化和销毁</td>
<td align="left">需要手动管理对象的生命周期</td>
</tr>
<tr>
<td align="left"><strong>配置集中化</strong></td>
<td align="left">通过配置文件或注解集中管理</td>
<td align="left">配置分散在代码中</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">适用于复杂的依赖关系和大型项目</td>
<td align="left">适用于简单的场景或非 Spring 项目</td>
</tr>
<tr>
<td align="left"><strong>代码耦合度</strong></td>
<td align="left">低耦合，易于维护和扩展</td>
<td align="left">高耦合，维护和扩展较困难</td>
</tr>
</tbody></table>
<h3 id="Spring-管理-DataSource-的优势"><a href="#Spring-管理-DataSource-的优势" class="headerlink" title="Spring 管理 DataSource 的优势"></a><strong>Spring 管理 <code>DataSource</code> 的优势</strong></h3><ul>
<li><strong>简化配置</strong>：通过配置文件或注解集中管理数据库连接信息。</li>
<li><strong>依赖注入</strong>：无需手动创建 <code>DataSource</code>，Spring 自动注入。</li>
<li><strong>连接池支持</strong>：Spring 支持多种连接池（如 HikariCP、Tomcat JDBC Pool），可以轻松切换。</li>
<li><strong>事务管理</strong>：Spring 提供了强大的事务管理功能，与 <code>DataSource</code> 无缝集成。</li>
</ul>
<p>表现层数据封装</p>
<p>前端接收数据格式-创建结果模型类，封装数据到data属性中。</p>
<p>前后端人员约定形式。</p>
<p>异常诱因：</p>
<p>框架内部抛出异常：使用不合规</p>
<p>数据层抛出的异常：外部服务器故障导致</p>
<p>业务层抛出的异常：业务罗欧锦书写错误导致</p>
<p>表现层抛出的异常：数据收集，校验等规则导致</p>
<p>工具类抛出的异常：因工具类书写不严谨不够健壮导致</p>
<p>异常处理：</p>
<p>所有异常放在表现层处理</p>
<p>以下是 <code>@RestControllerAdvice</code> 和 <code>@ExceptionHandler</code> 的对比表格：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>@RestControllerAdvice</code></th>
<th><code>@ExceptionHandler</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>定义全局异常处理类，结合 <code>@ExceptionHandler</code> 处理控制器抛出的异常。</td>
<td>标记处理特定异常的方法。</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>用于集中管理全局异常处理逻辑，通常与 <code>@ExceptionHandler</code> 一起使用。</td>
<td>用于处理控制器或 <code>@RestControllerAdvice</code> 类中抛出的特定异常。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>通常返回 <code>ResponseEntity</code> 或直接返回对象（自动转换为 JSON&#x2F;XML）。</td>
<td>通常返回 <code>ResponseEntity</code> 或直接返回对象（自动转换为 JSON&#x2F;XML）。</td>
</tr>
<tr>
<td><strong>作用范围</strong></td>
<td>默认全局生效，可通过 <code>basePackages</code> 或 <code>annotations</code> 限定范围。</td>
<td>仅在定义它的类中生效（控制器或 <code>@RestControllerAdvice</code> 类）。</td>
</tr>
<tr>
<td><strong>组合使用</strong></td>
<td>通常与 <code>@ExceptionHandler</code> 一起使用，提供全局异常处理能力。</td>
<td>通常与 <code>@RestControllerAdvice</code> 或控制器一起使用，处理特定异常。</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td><code>java @RestControllerAdvice public class GlobalExceptionHandler &#123; ... &#125; </code></td>
<td><code>java @ExceptionHandler(IllegalArgumentException.class) public ResponseEntity&lt;String&gt; handleException() &#123; ... &#125; </code></td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>更灵活，可以处理多个控制器的异常，并支持全局配置。</td>
<td>更具体，专注于处理特定异常。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>适用于需要统一处理多个控制器异常的复杂项目。</td>
<td>适用于处理特定控制器或特定异常的场景。</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>@RestControllerAdvice 更适合全局异常处理，集中管理异常逻辑。</p>
<p>@ExceptionHandler<code>更适合处理特定异常，通常与</code>@RestControllerAdvice&#96; 或控制器结合使用。</p>
<p>两者结合使用可以构建一个健壮的异常处理机制，提升代码的可维护性和可读性。</p>
<p>项目异常分类：</p>
<p>业务异常：</p>
<p>规范德用户行为产生的异常</p>
<p>不规范的用户产生的异常</p>
<p>解决：发送信息给用户，提醒规范操作</p>
<p>系统异常：</p>
<p>项目运行过程可预计且无法避免的异常</p>
<p>解决：发送信息给运维，记录日志</p>
<p>其他异常</p>
<p>编程人员未预期到的异常</p>
<p>解决：发送信息给编程，提醒维护，记录日志</p>
<h2 id="面试Star法则"><a href="#面试Star法则" class="headerlink" title="面试Star法则"></a>面试Star法则</h2><p>situation：事情是在什么情况发生；</p>
<p>task：你是如何明确你得任务得；</p>
<p>Action：争对这样得情况分析，你采用了什么行动方式</p>
<p>Result：结果怎么样，在这样得情况你学习到了什么</p>
<p>FAB法则：</p>
<p>feature：是什么</p>
<p>Advantage：比别人好在哪里</p>
<p>Benefit：如果雇佣你，招聘方会得到什么好处</p>
<p>项目经历怎么写：</p>
<p>1.对项目整体设计的一个感受</p>
<p>2.在这个项目中你负责什么，做了什么，担任什么角色</p>
<p>3.从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</p>
<p>4.在项目描述中，最好体现自己的综合素质</p>
<p>那些有价值的问题值得提问？</p>
<p>1.能不能谈谈你作为一个公司老员工对公司的感受？</p>
<p>2.能不能问一下，你当时因为什么原因加入这家公司，或者这家公司有那些地方吸引你？</p>
<p>3.我觉得我表现的不是太好，你有什么建议或者评价给我吗？</p>
<p>4.接下来我会有一段很长的空档期，有什么要注意或者建议学习的吗？</p>
<p>5这个为什么还招人</p>
<p>6.大概什么时候能给我回复呢？</p>
<h2 id="java复习"><a href="#java复习" class="headerlink" title="java复习"></a>java复习</h2><p>接口和抽象类的区别</p>
<p>1.接口的方法默认是public，所有方法在接口中不能实现（Java8后开始默认实现），抽象类可以有非抽象的方法</p>
<p>2.接口中的实例变量默认是final类型的，而抽象类则不一定</p>
<p>3.一个类可以实现多个接口，但最多实现一个抽象类</p>
<p>4.一个类实现接口的话要实现接口的所有的方法，而抽象类不一定</p>
<p>5.接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象，从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一个行为的规范</p>
<p>java集合框架</p>
<p>ArrayList与linkdeList异同：</p>
<p>1.是否保证线程安全：ArrayList与LinkedList都是不同的，也就是不保证线程安全。</p>
<p>2.底层数据结构：ArrayList底层使用的是Object数组；LinkedList底层使用的是双向链表数据结构。</p>
<p>3.插入和删除是否受元素位置的影响：ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</p>
<p>LinkedList采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似o(1)而数组为近似O(n);</p>
<p>4.是否支持快速随机访问：快速随机访问就是通过元素的序号快速获取元素对象（对应于get（int index）方法）。</p>
<p>5.内存空间占用：ArrayList的空间浪费主要体现在list列表的结尾会预留一定的容量空间，而LinkedList的空间浪费体现在它的每一个元素都需要消耗比ArrayList更多空间。</p>
<p>Vector</p>
<p>vector类的所有都是同步的。可以由两个线程安全地访问Vector对象，但是一个线程访问Vector地话代码要在同步上耗费大量的时间。</p>
<p>ArrayList不是同步的。所以不需要线程安全时考虑ArrayList。</p>
<p>HashMap与Hashtable的区别：</p>
<p>hashtable是线程安全的。里面的方法都经过synchronized修饰。</p>
<p>hashtable已经被淘汰了，效率低。</p>
<p>hashMap可以将null作为键，键只有一个，可以有多个键对应的值为null。</p>
<p>hashMap扩大2倍。</p>
<p>当链表长度超过默认长度8时，链表转换为红黑树，减少搜索时间。</p>
<p>hashMap与hashSet</p>
<p>hashSet底层是基于hashMap实现的。</p>
<p>collection</p>
<p>1.List</p>
<p>ArrayList</p>
<p>Vector</p>
<p>LinkedList</p>
<p>2.Set</p>
<p>HashSet</p>
<p>LinedHashSet</p>
<p>TreeSet</p>
<p>Map</p>
<p>Hashmap</p>
<p>LinkedHashMap</p>
<p>HashTable</p>
<p>TreeMap</p>
<p>Java多线程</p>
<p>1.synchoized关键字了解</p>
<p>解决的是多个线程之间访问的同步性，synchoized关键字可以保证被它修饰的方法或者代码快在任意时刻只能由一个线程执行。</p>
<p>2怎么使用synchronized关键字</p>
<p>修饰实例方法，作用于当前对象实例加锁，进入同步diamond前要获得当前对象实例的锁。</p>
<p>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。</p>
<p>synchronized与ReenTrantLock的区别</p>
<p>1.两者都是可重入锁</p>
<p>2.synchronized依赖于jvm厄尔ReenTrantLock依赖于API</p>
<p>3.ReenTranLock比synchronized增加了一些高级功能</p>
<p>如何解决多线程时变量数据不一致问题？</p>
<p>变量声明为volatile，这就指示jvm，这个变量是不稳定的，每次使用它都到主存中读取。作用：volatile关键字的主要作用是保证变量的可见性然后还有一个作用就是放在指令重排序。</p>
<p>synchronized与voliatile区别</p>
<p>voliatile是线程同步的轻量级实现，性能好，但是synchronized使用场景多（修饰方法以及代码块）</p>
<p>多线程访问volatile关键字不会发生阻塞，而synchronized可能会发送阻塞</p>
<p>volatile保证数据的可见性，不能保证数据的原子性。</p>
<p>volatile关键字主要用于解决变量在多个线程之间的可见性，而后者解决的是多个线程之间访问资源的同步性</p>
<p>为什么要使用线程池</p>
<p>线程池提供了一种现在和管理资源。每个线程池还维护一些基本统计信息。</p>
<p>好处：1.降低资源消耗。</p>
<p>2.提高响应速度</p>
<p>3.提高线程的可管理性。</p>
<p>实现Runnable和Callable接口区别：前者不会返回结果，后者会返回结果。</p>
<p>execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否。</p>
<p>submit用于执行提交需要返回值的任务。任务池返回一个future类型的对象，通过future对象可以判断任务是否执行成功。</p>
<h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>事务：是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p>银行转账，典型的事务。</p>
<p>默认mysql的事务自动提交，也就是说，当执行一条DML语句，mysql会立即隐式的提交事务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- 设置手动提交</span><br><span class="line">SET autocommit = 0;</span><br><span class="line"></span><br><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 执行SQL操作</span><br><span class="line">UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;</span><br><span class="line">UPDATE accounts SET balance = balance + 100 WHERE user_id = 2;</span><br><span class="line"></span><br><span class="line">-- 检查是否有错误</span><br><span class="line">-- 如果没有错误则提交</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 如果有错误则回滚</span><br><span class="line">-- ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 恢复自动提交</span><br><span class="line">SET autocommit = 1;</span><br></pre></td></tr></table></figure>





<p>事务的四大特性（ACID）是数据库操作的基石：</p>
<ol>
<li><strong>原子性</strong>：事务是不可分割的整体，所有操作要么全部成功，要么全部回滚，不存在中间状态。</li>
<li><strong>一致性</strong>：事务执行前后，数据库必须保持逻辑规则（如约束、触发器），确保数据始终有效。</li>
<li><strong>隔离性</strong>：并发事务相互隔离，防止脏读、幻读等问题，通过锁或MVCC机制实现。</li>
<li><strong>持久性</strong>：事务一旦提交，结果永久保存，即使系统故障也不丢失，依赖日志（如Redo Log）恢复。</li>
</ol>
<p>并发事务可能引发以下四类核心问题：</p>
<ol>
<li><strong>脏读</strong>（Dirty Read）<br>事务A读取了事务B<strong>未提交</strong>的修改数据，若事务B回滚，则事务A读到的是无效的”脏数据”。</li>
<li><strong>不可重复读</strong>（Non-repeatable Read）<br>事务A多次读取同一数据，期间事务B<strong>修改并提交</strong>了该数据，导致事务A前后读取结果不一致。</li>
<li><strong>幻读</strong>（Phantom Read）<br>事务A按条件查询数据，期间事务B<strong>新增或删除</strong>了符合该条件的记录，导致事务A两次查询结果集不同（如原本10条变为12条）。</li>
<li><strong>丢失更新</strong>（Lost Update）<br>两个事务同时读取并修改同一数据，后提交的事务会覆盖先提交的事务的修改（如并发扣款导致余额错误）。</li>
</ol>
<blockquote>
<p><strong>注</strong>：不可重复读针对数据值的变化，幻读针对数据行的增减。数据库通过<strong>隔离级别</strong>（如<code>READ COMMITTED</code>、<code>SERIALIZABLE</code>）控制这些问题。</p>
</blockquote>
<p>事务隔离级别分为四类，用于控制并发事务间的可见性：</p>
<ol>
<li><strong>读未提交（Read Uncommitted）</strong>：事务可读取其他事务未提交的数据，可能导致脏读、不可重复读和幻读，性能最高但安全性最差。</li>
<li><strong>读已提交（Read Committed）</strong>：只能读取已提交的数据，避免脏读，但可能出现不可重复读和幻读（如Oracle默认级别）。</li>
<li><strong>可重复读（Repeatable Read）</strong>：确保同一事务内多次读取数据结果一致，避免脏读和不可重复读，但可能发生幻读（MySQL默认级别）。</li>
<li><strong>串行化（Serializable）</strong>：完全隔离事务，通过强制排序避免所有并发问题，但性能最低，适用于严格要求一致性的场景。</li>
</ol>
<p>隔离级别越高，数据一致性越强，但并发性能越低，需根据业务需求权衡选择。</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>borker</p>
<p>kafka服务器进程，生产者、消费者都要连接broker</p>
<p>一个集群由度过broker组成，功能实现Kafka集群的负载均衡，容错</p>
<p>producer：生产者</p>
<p>consumer：消费者</p>
<p>topic：主题，一个Kafka集群中，可以包含多个topic。一个topic可以包含多个分区</p>
<p>是一个逻辑结构，生产消费消息都需要指定topic</p>
<p>partition：Kafka集群的分布式就是由分区来实现的。一个topic中的消息可以分布在topic中的不同paritition中。</p>
<p>replica：副本，实现Kafka集群的容错，实现partition的容错。一个topic至少包含大于1个的副本</p>
<p>consumer group：消费者组，一个消费组中的消费者可以共同消费topic中的分区数据。每一个消费组都一个唯一一个的名字。配置group-id一样的消费者是属于同一个组中。</p>
<p>offest：偏移量。相对于消费者来说，可以通过offest来拉取数据。</p>
<p>消费者组</p>
<p>一个消费者组中可以包含多个消费者，共同来消费topic中的数据。</p>
<p>一个topic中如果只有一个分区，那么这个分区只能被某个组的一个消费者消费</p>
<p>有多少个分区，那么就可以被同一个组内的多少个消费者消费。</p>
<p><strong>幂等性</strong>是指对同一个操作执行一次或多次，其产生的结果是相同的。在分布式系统和API设计中，幂等性是一个非常重要的概念。</p>
<h3 id="Kafka-就像「快递分拣中心」"><a href="#Kafka-就像「快递分拣中心」" class="headerlink" title="Kafka 就像「快递分拣中心」"></a><strong>Kafka 就像「快递分拣中心」</strong></h3><p><strong>生活案例</strong>：<br>假设你开了一家网红奶茶店，顾客线上下单后：  </p>
<ul>
<li><strong>没有 Kafka</strong>：订单直接交给制作员，高峰期时订单堆积，店员手忙脚乱，容易漏单或出错。  </li>
<li><strong>使用 Kafka</strong>：订单统一送到「智能分拣中心」（Kafka），自动按顺序排队、分发到多个制作台，还能：  <ul>
<li><strong>抗拥堵</strong>：即使瞬间涌入1000单，系统也能平稳处理（高吞吐）。  </li>
<li><strong>防丢单</strong>：所有订单记录在系统，即使停电也能恢复（持久化）。  </li>
<li><strong>灵活扩展</strong>：新增制作台（消费者）即可提高产能（水平扩展）。</li>
</ul>
</li>
</ul>
<p><strong>好处总结</strong>：<br>✅ <strong>订单不丢失</strong>（数据可靠）<br>✅ <strong>高峰期不卡顿</strong>（高并发）<br>✅ <strong>分工更高效</strong>（解耦生产与消费）  </p>
<p>就像分拣中心让奶茶店忙而不乱，Kafka 让数据流<strong>井然有序</strong>。</p>
<h3 id="RabbitMQ-就像「餐厅服务员」"><a href="#RabbitMQ-就像「餐厅服务员」" class="headerlink" title="RabbitMQ 就像「餐厅服务员」"></a><strong>RabbitMQ 就像「餐厅服务员」</strong></h3><p><strong>生活案例</strong>：<br>假设你经营一家火锅店，顾客通过扫码点餐：  </p>
<ul>
<li><strong>没有 RabbitMQ</strong>：订单直接打印到后厨，所有菜品一起处理，导致「毛肚等10分钟，青菜却先上」的混乱情况。  </li>
<li><strong>使用 RabbitMQ</strong>：订单交给「智能服务员」（RabbitMQ），它会：  <ul>
<li><strong>按规则分发</strong>：  <ul>
<li>肉类订单优先给切肉间（<strong>优先级队列</strong>）  </li>
<li>饮料订单直达吧台（<strong>路由规则</strong>）</li>
</ul>
</li>
<li><strong>灵活应对需求</strong>：  <ul>
<li>VIP订单插队处理（<strong>消息优先级</strong>）  </li>
<li>某菜品缺货时，自动通知顾客（<strong>死信队列</strong>）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>好处总结</strong>：<br>✅ <strong>精准投递</strong>（消息按规则路由）<br>✅ <strong>忙闲调配</strong>（消费者动态伸缩）<br>✅ <strong>异常处理</strong>（订单失败自动重试&#x2F;补偿）  </p>
<p>就像专业服务员让火锅店<strong>井井有条</strong>，RabbitMQ 让业务消息<strong>精准可控</strong>。  </p>
<hr>
<h3 id="对比记忆："><a href="#对比记忆：" class="headerlink" title="对比记忆："></a><strong>对比记忆</strong>：</h3><ul>
<li><strong>Kafka</strong>：快递分拣中心（<strong>海量订单快速流转</strong>）  </li>
<li><strong>RabbitMQ</strong>：餐厅服务员（<strong>精细调度每个任务</strong>）</li>
</ul>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>面向对象编程（OOP）的七大原则通常指的是SOLID原则加上额外的三个原则，这些原则帮助开发者创建更加健壮、可维护和灵活的软件系统。以下是这七个原则的简要介绍：</p>
<ol>
<li><p><strong>单一职责原则（Single Responsibility Principle, SRP）</strong>：</p>
<ul>
<li>一个类应该只有一个引起它变化的原因，即一个类只负责一项职责。这样可以使类更加专注于执行单一功能，从而提高内聚性。</li>
</ul>
</li>
<li><p><strong>开放封闭原则（Open&#x2F;Closed Principle, OCP）</strong>：</p>
<ul>
<li>软件实体（类、模块、函数等）应该是可以扩展的，但是不可修改。这意味着你可以通过添加新的代码来扩展功能，而不是改变现有的代码，有助于减少错误的风险。</li>
</ul>
</li>
<li><p><strong>里氏替换原则（Liskov Substitution Principle, LSP）</strong>：</p>
<ul>
<li>子类应当能够替换它们的基类而不影响程序的正确性。也就是说，使用基类的地方都可以透明地使用子类而不会出现问题。</li>
</ul>
</li>
<li><p><strong>接口隔离原则（Interface Segregation Principle, ISP）</strong>：</p>
<ul>
<li>不应该强迫客户端依赖于他们不使用的接口。换句话说，应将庞大的接口拆分成小而具体的接口，使得实现类只需关注自己需要的接口方法。</li>
</ul>
</li>
<li><p><strong>依赖倒置原则（Dependency Inversion Principle, DIP）</strong>：</p>
<ul>
<li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。该原则提倡使用接口或抽象类来减少具体实现之间的耦合度。</li>
</ul>
</li>
<li><p><strong>迪米特法则（Law of Demeter, LoD）</strong>：</p>
<ul>
<li>也被称为最少知识原则，指一个对象应当尽可能少地了解其他对象。具体来说，对象仅与直接的朋友交流，避免内部信息暴露给不必要的对象，增强封装性并降低耦合度。</li>
</ul>
</li>
<li><p><strong>组合&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle, CARP）</strong>：</p>
<ul>
<li>在新对象中尽量使用已有的对象去组合，而不是通过继承来达到复用的目的。相比继承，组合提供了更大的灵活性，并且减少了由于层次结构带来的复杂性和风险。</li>
</ul>
</li>
</ol>
<h3 id="HTTP协议结构"><a href="#HTTP协议结构" class="headerlink" title="HTTP协议结构"></a>HTTP协议结构</h3><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是用于分布式、协作式和超媒体信息系统的应用层协议。它是互联网数据通信的基础，特别是在浏览器与服务器之间的交互中扮演着关键角色。HTTP协议的请求和响应消息由以下几个主要部分组成：</p>
<ol>
<li><p><strong>起始行（Start Line）</strong>：</p>
<ul>
<li><strong>请求行（Request Line）</strong>：在请求消息中，它包含了请求方法（如GET、POST）、请求的URI（统一资源标识符）以及使用的HTTP版本。</li>
<li><strong>状态行（Status Line）</strong>：在响应消息中，它包括了HTTP版本、状态码（表明请求的结果如何）以及状态描述。</li>
</ul>
</li>
<li><p><strong>头部（Headers）</strong>：</p>
<ul>
<li>包含关于请求或响应的元数据，比如内容类型、字符编码、缓存指令等。分为通用头、请求头、响应头和实体头。</li>
</ul>
</li>
<li><p><strong>空行（Blank Line）</strong>：</p>
<ul>
<li>用来分隔头部和接下来的消息体。</li>
</ul>
</li>
<li><p><strong>消息体（Body）</strong>：</p>
<ul>
<li>可选的，包含实际传输的数据，如HTML文档、图片或其他类型的文件。并非所有的HTTP请求和响应都包含消息体。</li>
</ul>
</li>
</ol>
<h3 id="23种设计模式概览"><a href="#23种设计模式概览" class="headerlink" title="23种设计模式概览"></a>23种设计模式概览</h3><h3 id="创建型模式（Creational-Patterns）"><a href="#创建型模式（Creational-Patterns）" class="headerlink" title="创建型模式（Creational Patterns）"></a>创建型模式（Creational Patterns）</h3><ol>
<li><strong>单例模式（Singleton）</strong>：确保一个类只有一个实例，并提供全局访问点。</li>
<li><strong>工厂方法（Factory Method）</strong>：定义一个用于创建对象的接口，让子类决定实例化哪一个类。</li>
<li><strong>抽象工厂（Abstract Factory）</strong>：提供一系列相关或依赖对象的接口，而无需指定它们具体的类。</li>
<li><strong>建造者模式（Builder）</strong>：将复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li><strong>原型模式（Prototype）</strong>：通过复制现有实例来创建新实例，而不是通过实例化类来创建。</li>
</ol>
<h4 id="结构型模式（Structural-Patterns）"><a href="#结构型模式（Structural-Patterns）" class="headerlink" title="结构型模式（Structural Patterns）"></a>结构型模式（Structural Patterns）</h4><ol>
<li><strong>适配器模式（Adapter）</strong>：允许原本由于接口不兼容而不能一起工作的类能够协同工作。</li>
<li><strong>桥接模式（Bridge）</strong>：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li>
<li><strong>组合模式（Composite）</strong>：允许你将对象组合成树形结构来表示“部分-整体”的层次结构。</li>
<li><strong>装饰模式（Decorator）</strong>：动态地给一个对象添加一些额外的职责。</li>
<li><strong>外观模式（Facade）</strong>：为复杂的子系统提供一个统一的接口，简化其使用。</li>
<li><strong>享元模式（Flyweight）</strong>：运用共享技术有效地支持大量细粒度的对象。</li>
<li><strong>代理模式（Proxy）</strong>：为其他对象提供一种代理以控制对这个对象的访问。</li>
</ol>
<h4 id="行为型模式（Behavioral-Patterns）"><a href="#行为型模式（Behavioral-Patterns）" class="headerlink" title="行为型模式（Behavioral Patterns）"></a>行为型模式（Behavioral Patterns）</h4><ol>
<li><strong>观察者模式（Observer）</strong>：定义一种一对多的依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</li>
<li><strong>策略模式（Strategy）</strong>：定义一系列算法，把它们一个个封装起来，并使它们之间可以互换使用。</li>
<li><strong>模板方法（Template Method）</strong>：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。</li>
<li><strong>解释器模式（Interpreter）</strong>：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</li>
<li><strong>责任链模式（Chain of Responsibility）</strong>：避免请求发送者与接收者耦合在一起，让多个对象都有机会处理请求。</li>
<li><strong>命令模式（Command）</strong>：将请求封装成对象，从而使你可以用不同的请求对客户进行参数化。</li>
<li><strong>迭代器模式（Iterator）</strong>：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。</li>
<li><strong>中介者模式（Mediator）</strong>：用一个中介对象来封装一系列的对象交互。</li>
<li><strong>备忘录模式（Memento）</strong>：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</li>
<li><strong>状态模式（State）</strong>：允许对象在其内部状态改变时改变它的行为。</li>
<li><strong>访问者模式（Visitor）</strong>：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。</li>
</ol>
<h3 id="TCP3次握手和4次挥手"><a href="#TCP3次握手和4次挥手" class="headerlink" title="TCP3次握手和4次挥手"></a>TCP3次握手和4次挥手</h3><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>三次握手的主要目的是在客户端和服务器之间建立一条可靠的双向通信通道。它确保双方都准备好进行数据传输，并且能够同步初始序列号。以下是三次握手的过程：</p>
<ol>
<li><p><strong>第一次握手</strong>：客户端发送一个SYN（同步序列编号，Synchronize Sequence Numbers）包到服务器，表示请求建立连接，同时附带客户端的初始序列号。</p>
</li>
<li><p><strong>第二次握手</strong>：服务器接收到客户端的SYN包后，需要回复一个ACK（确认字符，Acknowledgement）包作为响应，表示已经接收到客户端的请求，并且也会发送自己的SYN包给客户端，这个步骤同时包含了对客户端SYN的确认以及服务器端的SYN请求。此时，服务器进入了SYN_RECEIVED状态。</p>
</li>
<li><p><strong>第三次握手</strong>：客户端收到服务器的SYN+ACK包后，会再次发送一个ACK包给服务器以确认连接，之后双方进入ESTABLISHED状态，即连接已建立，可以开始数据传输。</p>
</li>
</ol>
<h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p>四次挥手用于安全地关闭TCP连接，确保双方都已经完成了数据交换并且释放了资源。由于TCP连接是全双工的，意味着每个方向都需要独立关闭，因此需要四次挥手来完成这一过程：</p>
<ol>
<li><p><strong>第一次挥手</strong>：主动关闭方（通常是客户端或首先决定结束会话的一方）发送一个FIN（结束标志，Finish），表示希望断开连接。</p>
</li>
<li><p><strong>第二次挥手</strong>：被动关闭方（通常是服务器）接收到FIN后，会发送一个ACK作为响应，确认收到了对方的关闭请求。此时，主动关闭方到被动关闭方的方向上的连接被关闭，但被动关闭方到主动关闭方的方向仍可继续传输数据。</p>
</li>
<li><p><strong>第三次挥手</strong>：当被动关闭方也准备好了关闭连接时（即所有数据都已发送完毕），它会发送一个FIN给主动关闭方。</p>
</li>
<li><p><strong>第四次挥手</strong>：主动关闭方收到FIN后，会发送最后一个ACK作为响应，然后等待一段时间（通常称为TIME_WAIT状态），确保被动关闭方收到了确认信息。一旦这个时间段结束，连接才完全关闭。</p>
</li>
</ol>
<h3 id="从url回车到页面显示发送了什么？"><a href="#从url回车到页面显示发送了什么？" class="headerlink" title="从url回车到页面显示发送了什么？"></a>从url回车到页面显示发送了什么？</h3><p>从你在浏览器地址栏输入一个URL并按下回车键，直到页面完全显示出来，这个过程涉及多个步骤和协议。以下是详细的流程：</p>
<h4 id="1-DNS查询"><a href="#1-DNS查询" class="headerlink" title="1. DNS查询"></a>1. DNS查询</h4><ul>
<li><strong>域名解析</strong>：首先，浏览器需要将你输入的URL中的域名转换成IP地址。它会检查本地DNS缓存，如果没有找到对应的IP地址，则会向配置的DNS服务器发起查询请求。</li>
<li><strong>递归查询</strong>：如果本地DNS服务器没有记录，它将继续向其他DNS服务器查询，直到获得目标域名的IP地址。</li>
</ul>
<h4 id="2-建立TCP连接"><a href="#2-建立TCP连接" class="headerlink" title="2. 建立TCP连接"></a>2. 建立TCP连接</h4><ul>
<li><strong>三次握手</strong>：一旦获取了服务器的IP地址，浏览器会与该服务器建立TCP连接。这通过三次握手完成：<ol>
<li>客户端发送SYN包到服务器。</li>
<li>服务器回应SYN-ACK包给客户端。</li>
<li>客户端再发送ACK包确认连接，至此连接建立成功。</li>
</ol>
</li>
</ul>
<h4 id="3-发送HTTP-HTTPS请求"><a href="#3-发送HTTP-HTTPS请求" class="headerlink" title="3. 发送HTTP&#x2F;HTTPS请求"></a>3. 发送HTTP&#x2F;HTTPS请求</h4><ul>
<li><strong>HTTP请求</strong>：如果是HTTP请求，浏览器直接发送请求报文到服务器；如果是HTTPS请求，则在发送前还需要进行SSL&#x2F;TLS握手以加密通信。</li>
<li><strong>HTTPS握手</strong>：包括证书验证、密钥交换等步骤，确保数据传输的安全性。</li>
</ul>
<h4 id="4-接收响应"><a href="#4-接收响应" class="headerlink" title="4. 接收响应"></a>4. 接收响应</h4><ul>
<li><strong>服务器处理</strong>：服务器接收到请求后，根据请求的内容（如GET请求），查找相应的资源或执行相应的逻辑，并生成HTTP响应返回给客户端。</li>
<li><strong>状态码和消息体</strong>：响应包含状态码（如200表示成功）、响应头以及响应体（实际要展示的内容）。</li>
</ul>
<h4 id="5-渲染页面"><a href="#5-渲染页面" class="headerlink" title="5. 渲染页面"></a>5. 渲染页面</h4><ul>
<li><strong>HTML解析</strong>：浏览器开始解析返回的HTML文档，构建DOM树。</li>
<li><strong>CSS解析与渲染</strong>：同时加载外部样式表并解析CSS，构建CSSOM树，然后结合DOM树生成渲染树。</li>
<li><strong>JavaScript执行</strong>：遇到<code>&lt;script&gt;</code>标签时，暂停HTML解析，下载并执行脚本文件，之后继续解析剩余的HTML。</li>
<li><strong>布局与绘制</strong>：计算每个节点的位置大小等信息，完成布局后，将内容绘制到屏幕上。</li>
</ul>
<h4 id="6-加载附加资源"><a href="#6-加载附加资源" class="headerlink" title="6. 加载附加资源"></a>6. 加载附加资源</h4><ul>
<li><strong>异步加载</strong>：在整个过程中，浏览器还会异步加载图片、视频、字体等资源，并可能再次触发上述部分流程（如DNS查询、建立TCP连接等）。</li>
</ul>
<h4 id="7-结束"><a href="#7-结束" class="headerlink" title="7. 结束"></a>7. 结束</h4><ul>
<li>当所有资源都已加载完毕且页面完全渲染好后，用户就可以看到最终的网页了。</li>
</ul>
<p>整个过程包含了网络通信、协议处理、安全措施以及前端技术的应用等多个方面，是现代Web体验的基础。</p>
<h3 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h3><p>RabbitMQ在项目中主要用于实现系统间的异步通信和解耦，通过消息队列的方式让不同的服务能够独立地发送和接收消息，从而提高系统的响应速度和稳定性。它支持多种消息传递模式，如点对点和发布&#x2F;订阅，适用于处理耗时任务的异步执行、流量削峰、日志记录以及构建高可用性和可扩展性的分布式应用，确保即使在高负载情况下也能平稳运行并有效管理服务间的交互。简而言之，RabbitMQ帮助项目实现了更高效、灵活且可靠的服务间通信机制。</p>
<h3 id="RabbitMQ-深入讲解"><a href="#RabbitMQ-深入讲解" class="headerlink" title="RabbitMQ 深入讲解"></a>RabbitMQ 深入讲解</h3><p><strong>RabbitMQ</strong> 是一个开源的消息代理软件（消息队列），它实现了高级消息队列协议（AMQP）。RabbitMQ主要用于在分布式系统中提供可靠的消息传递服务，支持多种消息传递模式，并具有高度的可扩展性和灵活性。</p>
<ul>
<li><p><strong>核心概念</strong>：</p>
<ul>
<li><strong>生产者（Producer）</strong>：发送消息的应用程序。</li>
<li><strong>交换机（Exchange）</strong>：接收生产者发送的消息，并根据路由键（Routing Key）将消息转发到相应的队列。</li>
<li><strong>队列（Queue）</strong>：存储消息直到被消费者处理。</li>
<li><strong>绑定（Binding）</strong>：定义了交换机和队列之间的关系，包括路由规则。</li>
<li><strong>消费者（Consumer）</strong>：接收并处理队列中的消息的应用程序。</li>
</ul>
</li>
<li><p><strong>消息传递模式</strong>：</p>
<ul>
<li><strong>简单模式（Simple&#x2F;Around-robin Dispatching）</strong>：每个消息都被发送给下一个消费者。</li>
<li><strong>发布&#x2F;订阅模式（Publish&#x2F;Subscribe）</strong>：广播消息给所有消费者。</li>
<li><strong>路由模式（Routing）</strong>：基于路由键精确地发送消息给特定消费者。</li>
<li><strong>主题模式（Topics）</strong>：使用通配符路由键灵活地匹配消息到消费者。</li>
</ul>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li>支持消息持久化、确认机制确保消息不丢失。</li>
<li>提供高可用性配置，如集群、镜像队列等。</li>
<li>支持多种编程语言客户端，易于集成到现有系统中。</li>
</ul>
</li>
</ul>
<h3 id="Elasticsearch-深入讲解"><a href="#Elasticsearch-深入讲解" class="headerlink" title="Elasticsearch 深入讲解"></a>Elasticsearch 深入讲解</h3><p><strong>Elasticsearch</strong> 是一个分布式的搜索和分析引擎，基于Apache Lucene构建，专为大规模数据的实时搜索和分析而设计。它非常适合全文搜索、日志分析、应用监控等多种场景。</p>
<ul>
<li><p><strong>核心概念</strong>：</p>
<ul>
<li><strong>索引（Index）</strong>：类似于传统数据库中的“数据库”，是文档的集合。</li>
<li><strong>类型（Type）</strong>：早期版本中类似表的概念，但在较新版本中已被弃用，推荐使用单一类型。</li>
<li><strong>文档（Document）</strong>：以JSON格式存储的基本信息单元，对应于传统数据库中的行。</li>
<li><strong>映射（Mapping）</strong>：定义文档及其字段如何被存储和索引。</li>
<li><strong>分片（Shards）</strong>：索引可以分成多个分片，允许水平扩展。</li>
<li><strong>副本（Replicas）</strong>：为了提高容错性和查询性能，每个分片可以有多个副本。</li>
</ul>
</li>
<li><p><strong>功能特点</strong>：</p>
<ul>
<li><strong>全文搜索</strong>：强大的倒排索引技术实现快速准确的全文检索。</li>
<li><strong>聚合分析</strong>：支持复杂的统计分析和数据汇总。</li>
<li><strong>近实时搜索</strong>：新增或修改的数据可以在秒级内被搜索到。</li>
<li><strong>高可用性与扩展性</strong>：通过分片和副本机制支持大规模数据集和高并发访问。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>日志和事件数据分析。</li>
<li>实时应用程序监控和报警。</li>
<li>构建搜索引擎前端，如网站搜索、电子商务搜索等。</li>
</ul>
</li>
</ul>
<p>总之，RabbitMQ专注于解决分布式系统中的消息传递问题，提供可靠的异步通信机制；而Elasticsearch则致力于数据的搜索和分析，尤其擅长处理非结构化数据的快速检索和复杂查询。两者在现代软件架构中扮演着不同的角色，但都能显著提升系统的功能性和效率。</p>
<h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><h4 id="首先表态"><a href="#首先表态" class="headerlink" title="首先表态"></a>首先表态</h4><p>如果使用合理的JVM参数配置，在大多数情况下应该是不需要进行额外的调优的。合理的初始配置通常能够满足大部分应用的需求。</p>
<h4 id="其次说明"><a href="#其次说明" class="headerlink" title="其次说明"></a>其次说明</h4><p>尽管如此，仍然存在少量场景需要进一步调优。我们可以对一些JVM核心指标配置监控告警，当出现波动时人为介入分析评估。这些指标包括但不限于内存使用情况、垃圾回收频率和持续时间等。</p>
<h4 id="实际的调优例子"><a href="#实际的调优例子" class="headerlink" title="实际的调优例子"></a>实际的调优例子</h4><p>假设有一个Web应用在高负载下响应变慢，并且频繁出现Full GC导致长时间停顿。初步分析后发现是由于老年代内存不足引起。此时可以考虑如下调整：</p>
<ol>
<li><p><strong>增加堆内存大小</strong>：</p>
<ul>
<li>将最大堆大小（<code>-Xmx</code>）和初始堆大小（<code>-Xms</code>）设置为相同的值，以避免动态扩展带来的性能损耗。例如，从2GB增加到4GB。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms4G -Xmx4G</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调整年轻代大小</strong>：</p>
<ul>
<li>根据应用的特点调整年轻代大小（<code>-Xmn</code>）。较大的年轻代可以减少Minor GC次数但会增加每次GC的时间；较小的年轻代则相反。例如，可以尝试将年轻代设置为堆内存的三分之一。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmn1.5G</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>选择合适的垃圾收集器</strong>：</p>
<ul>
<li>切换到G1垃圾收集器（<code>-XX:+UseG1GC</code>），并根据应用需求微调G1相关的参数，例如期望的最大GC暂停时间。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC -XX:MaxGCPauseMillis=200</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启用详细日志记录</strong>：</p>
<ul>
<li>通过设置详细的GC日志记录来帮助分析GC行为。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>监控与分析</strong>：</p>
<ul>
<li>使用工具如JVisualVM或JConsole监控JVM的运行状况，包括CPU、内存使用情况、线程信息等。</li>
<li>设置监控告警，当出现异常波动时及时介入分析。</li>
</ul>
</li>
</ol>
<p>通过上述步骤，可以在特定场景下有效优化JVM的性能。合理配置JVM参数并结合有效的监控和分析工具，可以帮助我们更好地理解和优化应用程序的运行状态。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://gdhgxd.cn">gdh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://gdhgxd.cn/2025/04/28/sas%E5%AD%A6%E4%B9%A0/">http://gdhgxd.cn/2025/04/28/sas%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://gdhgxd.cn" target="_blank">gdh分享园</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/fengdan.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/28/vue/" title="力扣收获"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/qiqi.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">力扣收获</div></div><div class="info-2"><div class="info-item-1">##内容 三元运算符1234567三元运算符（`l1 != null ? l1.val : 0`）相当于int val1;if (l1 != null) &#123;    val1 = l1.val;&#125; else &#123;    val1 = 0;&#125;  以下是关于链表的详细解答，涵盖你提到的所有问题： 链表 1. 如何新建一个链表在 Java 中，链表是通过定义一个节点类（ListNode）来实现的。每个节点包含数据域和指针域。 定义链表节点12345678910class ListNode &#123;    int val;        // 数据域    ListNode next;  // 指针域，指向下一个节点    // 构造函数    ListNode(int val) &#123;        this.val = val;        this.next = null;    &#125;&#125;  创建链表通过创建多个节点并链接它们来构建链表： 12345678910// 创建节点ListNode node1 = new...</div></div></div></a><a class="pagination-related" href="/2025/04/28/%E8%BD%AF%E8%91%97%EF%BC%9A%E8%BD%AF%E4%BB%B6%E8%91%97%E4%BD%9C%E6%9D%83%EF%BC%8C%E5%BE%88%E6%B0%B4%EF%BC%8C%E6%9C%89%E4%B8%80%E4%B8%A4%E4%B8%AA%E5%B0%B1%E8%A1%8C%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%92%8C%E4%B8%93%E5%88%A9%E7%9B%B8%E6%AF%94/" title="软著申请"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E6%98%9F%E7%A9%BA.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">软著申请</div></div><div class="info-2"><div class="info-item-1">软著：软件著作权，很水，有一两个就行，不要和专利相比 登录：身份使用个人，登录后进行实名认证 软著申请 1.原始取得方式 2.软件全场 3输入版本号 4.权力范围：全部 软件分类：应用软件，原创，单独开发（合作开发需要合作开发协议），开发日期，发表状态未发表 事业单位法人，名字写学校 软件功能与特点 硬件软件：写电脑配置 软件环境：开发软件，系统 源程序量：以3000行为分界线，以上大概，以下实际 软件技术特点：实在不行选教育软件和智慧城市软件 重新鉴别材料就是源程序代码，每页不少于50行，尽量去除注释 要设置页眉，需要软件名字 申请表：申请人签章就第一个人 设计说明书：设计思想，框架，流程图 使用手册：具体的可视化，登录界面，功能等 文档，页码要在右上角，左侧写系统名称和版本号 源代码不允许出现版权copyright,create,Author等（含相应中文），即清楚日期和版本相关注释 </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">gdh</div><div class="author-info-description">一个小小的程序员的小世界</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hunanshifangdh"><i class="fab fa-github"></i><span>gdh</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/hunanshifangdh/hunanshifangdh.github.io" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:admin@fomal.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">使用场景：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ElementType-%E6%9E%9A%E4%B8%BE%E5%80%BC%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">ElementType 枚举值：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BaseMapper-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">BaseMapper&lt;T&gt; 接口中定义的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MS%E7%9A%84%E5%AD%A6%E4%B9%A0"><span class="toc-number"></span> <span class="toc-text">MS的学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BD%9C%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">工具类作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E5%88%A4%E6%96%AD"><span class="toc-number"></span> <span class="toc-text">服务器网络判断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87"><span class="toc-number"></span> <span class="toc-text">java面试准备:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%AF%87"><span class="toc-number"></span> <span class="toc-text">redis篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%82%A3%E4%BA%9B%E4%BD%BF%E7%94%A8%E4%BA%86redis%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">最近的项目中那些使用了redis？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.1.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80"><span class="toc-number">1.1.1.</span> <span class="toc-text">解决方案一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BA%8C"><span class="toc-number">1.1.2.</span> <span class="toc-text">解决方案二</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">1.2.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">解决方案一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BA%8C-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">解决方案二</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.3.</span> <span class="toc-text">缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">解决方案</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E5%AD%A6%E4%B9%A0"><span class="toc-number"></span> <span class="toc-text">docker学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">项目部署问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BDdocker"><span class="toc-number">1.1.</span> <span class="toc-text">卸载docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85yum%E5%B7%A5%E5%85%B7%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">安装yum工具：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%95%9C%E5%83%8F%E6%BA%90%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">更新镜像源：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.</span> <span class="toc-text">输入命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">docker基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AAnginx%E5%AE%B9%E5%99%A8"><span class="toc-number">0.1.</span> <span class="toc-text">创建运行一个nginx容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%EF%BC%8C%E4%BF%AE%E6%94%B9HTML%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-number">0.2.</span> <span class="toc-text">进入容器内部，修改HTML文件内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">0.3.</span> <span class="toc-text">数据卷</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0"><span class="toc-number"></span> <span class="toc-text">微服务学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#eureka%E6%A1%86%E6%9E%B6"><span class="toc-number"></span> <span class="toc-text">eureka框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EurekaServer%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">1.</span> <span class="toc-text">EurekaServer：服务端，注册中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EurekaClient%EF%BC%9A%E5%AE%A2%E6%9C%8D%E7%AB%AF"><span class="toc-number">2.</span> <span class="toc-text">EurekaClient：客服端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">调整负载均衡规则：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#springMvc"><span class="toc-number"></span> <span class="toc-text">springMvc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E4%B8%BA%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dspring%E9%94%99%E8%AF%AF%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%88%B0springMvc%E7%9A%84bean%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">因为功能不同，如何避免spring错误的加载到springMvc的bean？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot-%E8%A7%A3%E5%86%B3-Spring-%E4%B8%8E-Spring-MVC-%E7%9A%84-Bean-%E6%89%AB%E6%8F%8F%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">Spring Boot 解决 Spring 与 Spring MVC 的 Bean 扫描问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F%E5%88%86%E7%A6%BB"><span class="toc-number">2.1.</span> <span class="toc-text">1. 自动配置与组件扫描分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8C%BA%E5%88%86-Web-%E5%92%8C%E9%9D%9E-Web-%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.</span> <span class="toc-text">2. 区分 Web 和非 Web 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">3. 内部实现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE"><span class="toc-number">2.4.</span> <span class="toc-text">4. 自定义配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%81%BF%E5%85%8D%E5%86%B2%E7%AA%81%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.5.</span> <span class="toc-text">5. 避免冲突的最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pojo%E4%B8%8Ejson%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">pojo与json区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">什么是代理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">什么是代理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">6.</span> <span class="toc-text">1. 反射的核心功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">2. 反射的核心类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96-Class-%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.1.</span> <span class="toc-text">(1) 获取 Class 对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">8.</span> <span class="toc-text">5. 反射的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">8.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">8.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E7%AE%A1%E7%90%86%E4%B8%8E%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">Spring 管理与方法调用的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E7%AE%A1%E7%90%86-DataSource-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">10.</span> <span class="toc-text">Spring 管理 DataSource 的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">11.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95Star%E6%B3%95%E5%88%99"><span class="toc-number"></span> <span class="toc-text">面试Star法则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%A4%8D%E4%B9%A0"><span class="toc-number"></span> <span class="toc-text">java复习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql"><span class="toc-number">1.</span> <span class="toc-text">Mysql</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka"><span class="toc-number"></span> <span class="toc-text">Kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka-%E5%B0%B1%E5%83%8F%E3%80%8C%E5%BF%AB%E9%80%92%E5%88%86%E6%8B%A3%E4%B8%AD%E5%BF%83%E3%80%8D"><span class="toc-number">1.</span> <span class="toc-text">Kafka 就像「快递分拣中心」</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E5%B0%B1%E5%83%8F%E3%80%8C%E9%A4%90%E5%8E%85%E6%9C%8D%E5%8A%A1%E5%91%98%E3%80%8D"><span class="toc-number">2.</span> <span class="toc-text">RabbitMQ 就像「餐厅服务员」</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E8%AE%B0%E5%BF%86%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">对比记忆：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95"><span class="toc-number"></span> <span class="toc-text">面试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">HTTP协议结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88"><span class="toc-number">2.</span> <span class="toc-text">23种设计模式概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Creational-Patterns%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">创建型模式（Creational Patterns）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Structural-Patterns%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">结构型模式（Structural Patterns）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Behavioral-Patterns%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">行为型模式（Behavioral Patterns）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP3%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C4%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">4.</span> <span class="toc-text">TCP3次握手和4次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">4.1.</span> <span class="toc-text">TCP三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">4.2.</span> <span class="toc-text">TCP四次挥手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8Eurl%E5%9B%9E%E8%BD%A6%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%8F%91%E9%80%81%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">从url回车到页面显示发送了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-DNS%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.1.</span> <span class="toc-text">1. DNS查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.2.</span> <span class="toc-text">2. 建立TCP连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%91%E9%80%81HTTP-HTTPS%E8%AF%B7%E6%B1%82"><span class="toc-number">5.3.</span> <span class="toc-text">3. 发送HTTP&#x2F;HTTPS请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8E%A5%E6%94%B6%E5%93%8D%E5%BA%94"><span class="toc-number">5.4.</span> <span class="toc-text">4. 接收响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2"><span class="toc-number">5.5.</span> <span class="toc-text">5. 渲染页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%8A%A0%E8%BD%BD%E9%99%84%E5%8A%A0%E8%B5%84%E6%BA%90"><span class="toc-number">5.6.</span> <span class="toc-text">6. 加载附加资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%BB%93%E6%9D%9F"><span class="toc-number">5.7.</span> <span class="toc-text">7. 结束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E7%AE%80%E4%BB%8B"><span class="toc-number">6.</span> <span class="toc-text">RabbitMQ简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3"><span class="toc-number">7.</span> <span class="toc-text">RabbitMQ 深入讲解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Elasticsearch-%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">Elasticsearch 深入讲解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98"><span class="toc-number">9.</span> <span class="toc-text">JVM调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E8%A1%A8%E6%80%81"><span class="toc-number">9.1.</span> <span class="toc-text">首先表态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E6%AC%A1%E8%AF%B4%E6%98%8E"><span class="toc-number">9.2.</span> <span class="toc-text">其次说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E7%9A%84%E8%B0%83%E4%BC%98%E4%BE%8B%E5%AD%90"><span class="toc-number">9.3.</span> <span class="toc-text">实际的调优例子</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/28/2025-4-28-hexo%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" title="hexo第一篇文章"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E6%98%9F%E7%A9%BA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo第一篇文章"/></a><div class="content"><a class="title" href="/2025/04/28/2025-4-28-hexo%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" title="hexo第一篇文章">hexo第一篇文章</a><time datetime="2025-04-28T08:58:00.000Z" title="发表于 2025-04-28 16:58:00">2025-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/28/Swagger/" title="swagger"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/keqina.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="swagger"/></a><div class="content"><a class="title" href="/2025/04/28/Swagger/" title="swagger">swagger</a><time datetime="2025-04-28T08:58:00.000Z" title="发表于 2025-04-28 16:58:00">2025-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/28/git%E5%AD%A6%E4%B9%A0/" title="git学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/guizhong.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git学习"/></a><div class="content"><a class="title" href="/2025/04/28/git%E5%AD%A6%E4%B9%A0/" title="git学习">git学习</a><time datetime="2025-04-28T08:58:00.000Z" title="发表于 2025-04-28 16:58:00">2025-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/28/springclound%E5%AD%A6%E4%B9%A0/" title="springcloud学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%8F%8B%E4%BA%BA%E5%9B%A2%E8%81%9A.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="springcloud学习"/></a><div class="content"><a class="title" href="/2025/04/28/springclound%E5%AD%A6%E4%B9%A0/" title="springcloud学习">springcloud学习</a><time datetime="2025-04-28T08:58:00.000Z" title="发表于 2025-04-28 16:58:00">2025-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/28/vue/" title="力扣收获"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/qiqi.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="力扣收获"/></a><div class="content"><a class="title" href="/2025/04/28/vue/" title="力扣收获">力扣收获</a><time datetime="2025-04-28T08:58:00.000Z" title="发表于 2025-04-28 16:58:00">2025-04-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By gdh</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>